// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  admin: (where?: AdminWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  admin: (where: AdminWhereUniqueInput) => AdminNullablePromise;
  admins: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admin>;
  adminsConnection: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => ScheduleNullablePromise;
  schedules: (args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Schedule>;
  schedulesConnection: (args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ScheduleConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdmin: (data: AdminCreateInput) => AdminPromise;
  updateAdmin: (args: {
    data: AdminUpdateInput;
    where: AdminWhereUniqueInput;
  }) => AdminPromise;
  updateManyAdmins: (args: {
    data: AdminUpdateManyMutationInput;
    where?: AdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAdmin: (args: {
    where: AdminWhereUniqueInput;
    create: AdminCreateInput;
    update: AdminUpdateInput;
  }) => AdminPromise;
  deleteAdmin: (where: AdminWhereUniqueInput) => AdminPromise;
  deleteManyAdmins: (where?: AdminWhereInput) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (args: {
    data: ScheduleUpdateInput;
    where: ScheduleWhereUniqueInput;
  }) => SchedulePromise;
  updateManySchedules: (args: {
    data: ScheduleUpdateManyMutationInput;
    where?: ScheduleWhereInput;
  }) => BatchPayloadPromise;
  upsertSchedule: (args: {
    where: ScheduleWhereUniqueInput;
    create: ScheduleCreateInput;
    update: ScheduleUpdateInput;
  }) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  admin: (
    where?: AdminSubscriptionWhereInput
  ) => AdminSubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "nameSchedule_ASC"
  | "nameSchedule_DESC"
  | "year_ASC"
  | "year_DESC"
  | "amountOfWorkingHours_ASC"
  | "amountOfWorkingHours_DESC"
  | "typeOfWeek_ASC"
  | "typeOfWeek_DESC"
  | "theader_ASC"
  | "theader_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fullname_ASC"
  | "fullname_DESC"
  | "rateOfWork_ASC"
  | "rateOfWork_DESC";

export type AdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "language_ASC"
  | "language_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdminWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ScheduleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nameSchedule?: Maybe<String>;
  nameSchedule_not?: Maybe<String>;
  nameSchedule_in?: Maybe<String[] | String>;
  nameSchedule_not_in?: Maybe<String[] | String>;
  nameSchedule_lt?: Maybe<String>;
  nameSchedule_lte?: Maybe<String>;
  nameSchedule_gt?: Maybe<String>;
  nameSchedule_gte?: Maybe<String>;
  nameSchedule_contains?: Maybe<String>;
  nameSchedule_not_contains?: Maybe<String>;
  nameSchedule_starts_with?: Maybe<String>;
  nameSchedule_not_starts_with?: Maybe<String>;
  nameSchedule_ends_with?: Maybe<String>;
  nameSchedule_not_ends_with?: Maybe<String>;
  owner?: Maybe<AdminWhereInput>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  month?: Maybe<MonthWhereInput>;
  amountOfWorkingHours?: Maybe<Float>;
  amountOfWorkingHours_not?: Maybe<Float>;
  amountOfWorkingHours_in?: Maybe<Float[] | Float>;
  amountOfWorkingHours_not_in?: Maybe<Float[] | Float>;
  amountOfWorkingHours_lt?: Maybe<Float>;
  amountOfWorkingHours_lte?: Maybe<Float>;
  amountOfWorkingHours_gt?: Maybe<Float>;
  amountOfWorkingHours_gte?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  typeOfWeek_not?: Maybe<Float>;
  typeOfWeek_in?: Maybe<Float[] | Float>;
  typeOfWeek_not_in?: Maybe<Float[] | Float>;
  typeOfWeek_lt?: Maybe<Float>;
  typeOfWeek_lte?: Maybe<Float>;
  typeOfWeek_gt?: Maybe<Float>;
  typeOfWeek_gte?: Maybe<Float>;
  theader?: Maybe<String>;
  theader_not?: Maybe<String>;
  theader_in?: Maybe<String[] | String>;
  theader_not_in?: Maybe<String[] | String>;
  theader_lt?: Maybe<String>;
  theader_lte?: Maybe<String>;
  theader_gt?: Maybe<String>;
  theader_gte?: Maybe<String>;
  theader_contains?: Maybe<String>;
  theader_not_contains?: Maybe<String>;
  theader_starts_with?: Maybe<String>;
  theader_not_starts_with?: Maybe<String>;
  theader_ends_with?: Maybe<String>;
  theader_not_ends_with?: Maybe<String>;
  employees_some?: Maybe<EmployeeWhereInput>;
  employees_every?: Maybe<EmployeeRestrictedWhereInput>;
  employees_none?: Maybe<EmployeeRestrictedWhereInput>;
  AND?: Maybe<ScheduleWhereInput[] | ScheduleWhereInput>;
}

export interface AdminWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  language?: Maybe<String>;
  language_not?: Maybe<String>;
  language_in?: Maybe<String[] | String>;
  language_not_in?: Maybe<String[] | String>;
  language_lt?: Maybe<String>;
  language_lte?: Maybe<String>;
  language_gt?: Maybe<String>;
  language_gte?: Maybe<String>;
  language_contains?: Maybe<String>;
  language_not_contains?: Maybe<String>;
  language_starts_with?: Maybe<String>;
  language_not_starts_with?: Maybe<String>;
  language_ends_with?: Maybe<String>;
  language_not_ends_with?: Maybe<String>;
  schedules_some?: Maybe<ScheduleWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  AND?: Maybe<AdminWhereInput[] | AdminWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  owner?: Maybe<AdminWhereInput>;
  position?: Maybe<PositionWhereInput>;
  rateOfWork?: Maybe<Float>;
  rateOfWork_not?: Maybe<Float>;
  rateOfWork_in?: Maybe<Float[] | Float>;
  rateOfWork_not_in?: Maybe<Float[] | Float>;
  rateOfWork_lt?: Maybe<Float>;
  rateOfWork_lte?: Maybe<Float>;
  rateOfWork_gt?: Maybe<Float>;
  rateOfWork_gte?: Maybe<Float>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PositionWhereInput {
  namePosition?: Maybe<String>;
  namePosition_not?: Maybe<String>;
  namePosition_in?: Maybe<String[] | String>;
  namePosition_not_in?: Maybe<String[] | String>;
  namePosition_lt?: Maybe<String>;
  namePosition_lte?: Maybe<String>;
  namePosition_gt?: Maybe<String>;
  namePosition_gte?: Maybe<String>;
  namePosition_contains?: Maybe<String>;
  namePosition_not_contains?: Maybe<String>;
  namePosition_starts_with?: Maybe<String>;
  namePosition_not_starts_with?: Maybe<String>;
  namePosition_ends_with?: Maybe<String>;
  namePosition_not_ends_with?: Maybe<String>;
  hoursOfWork?: Maybe<WorkTimeWhereInput>;
  secondHoursOfWork?: Maybe<SecondWorkTimeWhereInput>;
  lunch?: Maybe<LunchTimeWhereInput>;
  secondLunch?: Maybe<SecondLunchTimeWhereInput>;
  fulltime?: Maybe<Boolean>;
  fulltime_not?: Maybe<Boolean>;
  longOfDay?: Maybe<String>;
  longOfDay_not?: Maybe<String>;
  longOfDay_in?: Maybe<String[] | String>;
  longOfDay_not_in?: Maybe<String[] | String>;
  longOfDay_lt?: Maybe<String>;
  longOfDay_lte?: Maybe<String>;
  longOfDay_gt?: Maybe<String>;
  longOfDay_gte?: Maybe<String>;
  longOfDay_contains?: Maybe<String>;
  longOfDay_not_contains?: Maybe<String>;
  longOfDay_starts_with?: Maybe<String>;
  longOfDay_not_starts_with?: Maybe<String>;
  longOfDay_ends_with?: Maybe<String>;
  longOfDay_not_ends_with?: Maybe<String>;
  hoursOfMonth?: Maybe<String>;
  hoursOfMonth_not?: Maybe<String>;
  hoursOfMonth_in?: Maybe<String[] | String>;
  hoursOfMonth_not_in?: Maybe<String[] | String>;
  hoursOfMonth_lt?: Maybe<String>;
  hoursOfMonth_lte?: Maybe<String>;
  hoursOfMonth_gt?: Maybe<String>;
  hoursOfMonth_gte?: Maybe<String>;
  hoursOfMonth_contains?: Maybe<String>;
  hoursOfMonth_not_contains?: Maybe<String>;
  hoursOfMonth_starts_with?: Maybe<String>;
  hoursOfMonth_not_starts_with?: Maybe<String>;
  hoursOfMonth_ends_with?: Maybe<String>;
  hoursOfMonth_not_ends_with?: Maybe<String>;
  AND?: Maybe<PositionWhereInput[] | PositionWhereInput>;
}

export interface WorkTimeWhereInput {
  startWork?: Maybe<String>;
  startWork_not?: Maybe<String>;
  startWork_in?: Maybe<String[] | String>;
  startWork_not_in?: Maybe<String[] | String>;
  startWork_lt?: Maybe<String>;
  startWork_lte?: Maybe<String>;
  startWork_gt?: Maybe<String>;
  startWork_gte?: Maybe<String>;
  startWork_contains?: Maybe<String>;
  startWork_not_contains?: Maybe<String>;
  startWork_starts_with?: Maybe<String>;
  startWork_not_starts_with?: Maybe<String>;
  startWork_ends_with?: Maybe<String>;
  startWork_not_ends_with?: Maybe<String>;
  endWork?: Maybe<String>;
  endWork_not?: Maybe<String>;
  endWork_in?: Maybe<String[] | String>;
  endWork_not_in?: Maybe<String[] | String>;
  endWork_lt?: Maybe<String>;
  endWork_lte?: Maybe<String>;
  endWork_gt?: Maybe<String>;
  endWork_gte?: Maybe<String>;
  endWork_contains?: Maybe<String>;
  endWork_not_contains?: Maybe<String>;
  endWork_starts_with?: Maybe<String>;
  endWork_not_starts_with?: Maybe<String>;
  endWork_ends_with?: Maybe<String>;
  endWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<WorkTimeWhereInput[] | WorkTimeWhereInput>;
}

export interface SecondWorkTimeWhereInput {
  startSecondWork?: Maybe<String>;
  startSecondWork_not?: Maybe<String>;
  startSecondWork_in?: Maybe<String[] | String>;
  startSecondWork_not_in?: Maybe<String[] | String>;
  startSecondWork_lt?: Maybe<String>;
  startSecondWork_lte?: Maybe<String>;
  startSecondWork_gt?: Maybe<String>;
  startSecondWork_gte?: Maybe<String>;
  startSecondWork_contains?: Maybe<String>;
  startSecondWork_not_contains?: Maybe<String>;
  startSecondWork_starts_with?: Maybe<String>;
  startSecondWork_not_starts_with?: Maybe<String>;
  startSecondWork_ends_with?: Maybe<String>;
  startSecondWork_not_ends_with?: Maybe<String>;
  endSecondWork?: Maybe<String>;
  endSecondWork_not?: Maybe<String>;
  endSecondWork_in?: Maybe<String[] | String>;
  endSecondWork_not_in?: Maybe<String[] | String>;
  endSecondWork_lt?: Maybe<String>;
  endSecondWork_lte?: Maybe<String>;
  endSecondWork_gt?: Maybe<String>;
  endSecondWork_gte?: Maybe<String>;
  endSecondWork_contains?: Maybe<String>;
  endSecondWork_not_contains?: Maybe<String>;
  endSecondWork_starts_with?: Maybe<String>;
  endSecondWork_not_starts_with?: Maybe<String>;
  endSecondWork_ends_with?: Maybe<String>;
  endSecondWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<SecondWorkTimeWhereInput[] | SecondWorkTimeWhereInput>;
}

export interface LunchTimeWhereInput {
  startLunch?: Maybe<String>;
  startLunch_not?: Maybe<String>;
  startLunch_in?: Maybe<String[] | String>;
  startLunch_not_in?: Maybe<String[] | String>;
  startLunch_lt?: Maybe<String>;
  startLunch_lte?: Maybe<String>;
  startLunch_gt?: Maybe<String>;
  startLunch_gte?: Maybe<String>;
  startLunch_contains?: Maybe<String>;
  startLunch_not_contains?: Maybe<String>;
  startLunch_starts_with?: Maybe<String>;
  startLunch_not_starts_with?: Maybe<String>;
  startLunch_ends_with?: Maybe<String>;
  startLunch_not_ends_with?: Maybe<String>;
  endLunch?: Maybe<String>;
  endLunch_not?: Maybe<String>;
  endLunch_in?: Maybe<String[] | String>;
  endLunch_not_in?: Maybe<String[] | String>;
  endLunch_lt?: Maybe<String>;
  endLunch_lte?: Maybe<String>;
  endLunch_gt?: Maybe<String>;
  endLunch_gte?: Maybe<String>;
  endLunch_contains?: Maybe<String>;
  endLunch_not_contains?: Maybe<String>;
  endLunch_starts_with?: Maybe<String>;
  endLunch_not_starts_with?: Maybe<String>;
  endLunch_ends_with?: Maybe<String>;
  endLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<LunchTimeWhereInput[] | LunchTimeWhereInput>;
}

export interface SecondLunchTimeWhereInput {
  startSecondLunch?: Maybe<String>;
  startSecondLunch_not?: Maybe<String>;
  startSecondLunch_in?: Maybe<String[] | String>;
  startSecondLunch_not_in?: Maybe<String[] | String>;
  startSecondLunch_lt?: Maybe<String>;
  startSecondLunch_lte?: Maybe<String>;
  startSecondLunch_gt?: Maybe<String>;
  startSecondLunch_gte?: Maybe<String>;
  startSecondLunch_contains?: Maybe<String>;
  startSecondLunch_not_contains?: Maybe<String>;
  startSecondLunch_starts_with?: Maybe<String>;
  startSecondLunch_not_starts_with?: Maybe<String>;
  startSecondLunch_ends_with?: Maybe<String>;
  startSecondLunch_not_ends_with?: Maybe<String>;
  endSecondLunch?: Maybe<String>;
  endSecondLunch_not?: Maybe<String>;
  endSecondLunch_in?: Maybe<String[] | String>;
  endSecondLunch_not_in?: Maybe<String[] | String>;
  endSecondLunch_lt?: Maybe<String>;
  endSecondLunch_lte?: Maybe<String>;
  endSecondLunch_gt?: Maybe<String>;
  endSecondLunch_gte?: Maybe<String>;
  endSecondLunch_contains?: Maybe<String>;
  endSecondLunch_not_contains?: Maybe<String>;
  endSecondLunch_starts_with?: Maybe<String>;
  endSecondLunch_not_starts_with?: Maybe<String>;
  endSecondLunch_ends_with?: Maybe<String>;
  endSecondLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<SecondLunchTimeWhereInput[] | SecondLunchTimeWhereInput>;
}

export interface MonthWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  days_some?: Maybe<DayWhereInput>;
  days_every?: Maybe<DayRestrictedWhereInput>;
  days_none?: Maybe<DayRestrictedWhereInput>;
  nameOfMonth?: Maybe<String>;
  nameOfMonth_not?: Maybe<String>;
  nameOfMonth_in?: Maybe<String[] | String>;
  nameOfMonth_not_in?: Maybe<String[] | String>;
  nameOfMonth_lt?: Maybe<String>;
  nameOfMonth_lte?: Maybe<String>;
  nameOfMonth_gt?: Maybe<String>;
  nameOfMonth_gte?: Maybe<String>;
  nameOfMonth_contains?: Maybe<String>;
  nameOfMonth_not_contains?: Maybe<String>;
  nameOfMonth_starts_with?: Maybe<String>;
  nameOfMonth_not_starts_with?: Maybe<String>;
  nameOfMonth_ends_with?: Maybe<String>;
  nameOfMonth_not_ends_with?: Maybe<String>;
  daysAmount?: Maybe<Int>;
  daysAmount_not?: Maybe<Int>;
  daysAmount_in?: Maybe<Int[] | Int>;
  daysAmount_not_in?: Maybe<Int[] | Int>;
  daysAmount_lt?: Maybe<Int>;
  daysAmount_lte?: Maybe<Int>;
  daysAmount_gt?: Maybe<Int>;
  daysAmount_gte?: Maybe<Int>;
  weekdays_some?: Maybe<WeekdayWhereInput>;
  weekdays_every?: Maybe<WeekdayRestrictedWhereInput>;
  weekdays_none?: Maybe<WeekdayRestrictedWhereInput>;
  weekends_some?: Maybe<WeekendWhereInput>;
  weekends_every?: Maybe<WeekendRestrictedWhereInput>;
  weekends_none?: Maybe<WeekendRestrictedWhereInput>;
  holidays_some?: Maybe<HolidayWhereInput>;
  holidays_every?: Maybe<HolidayRestrictedWhereInput>;
  holidays_none?: Maybe<HolidayRestrictedWhereInput>;
  beforeHolidays_some?: Maybe<BeforeHolidayWhereInput>;
  beforeHolidays_every?: Maybe<BeforeHolidayRestrictedWhereInput>;
  beforeHolidays_none?: Maybe<BeforeHolidayRestrictedWhereInput>;
  AND?: Maybe<MonthWhereInput[] | MonthWhereInput>;
}

export interface DayWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  kindOfDay?: Maybe<KindOfDayWhereInput>;
  AND?: Maybe<DayWhereInput[] | DayWhereInput>;
}

export interface KindOfDayWhereInput {
  businessTrip?: Maybe<Boolean>;
  businessTrip_not?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  study_not?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  studyAdd_not?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  unknown_not?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  absenteeism_not?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  goverment_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  disease_not?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  vacation_not?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  childCare_not?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  admVacation_not?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  overTime_not?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  nightTime_not?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
  working_not?: Maybe<Boolean>;
  AND?: Maybe<KindOfDayWhereInput[] | KindOfDayWhereInput>;
}

export interface DayRestrictedWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  kindOfDay?: Maybe<KindOfDayRestrictedWhereInput>;
  AND?: Maybe<DayRestrictedWhereInput[] | DayRestrictedWhereInput>;
}

export interface KindOfDayRestrictedWhereInput {
  businessTrip?: Maybe<Boolean>;
  businessTrip_not?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  study_not?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  studyAdd_not?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  unknown_not?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  absenteeism_not?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  goverment_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  disease_not?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  vacation_not?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  childCare_not?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  admVacation_not?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  overTime_not?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  nightTime_not?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
  working_not?: Maybe<Boolean>;
  AND?: Maybe<KindOfDayRestrictedWhereInput[] | KindOfDayRestrictedWhereInput>;
}

export interface WeekdayWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekdayWhereInput[] | WeekdayWhereInput>;
}

export interface WeekdayRestrictedWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekdayRestrictedWhereInput[] | WeekdayRestrictedWhereInput>;
}

export interface WeekendWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekendWhereInput[] | WeekendWhereInput>;
}

export interface WeekendRestrictedWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekendRestrictedWhereInput[] | WeekendRestrictedWhereInput>;
}

export interface HolidayWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<HolidayWhereInput[] | HolidayWhereInput>;
}

export interface HolidayRestrictedWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<HolidayRestrictedWhereInput[] | HolidayRestrictedWhereInput>;
}

export interface BeforeHolidayWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<BeforeHolidayWhereInput[] | BeforeHolidayWhereInput>;
}

export interface BeforeHolidayRestrictedWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<
    BeforeHolidayRestrictedWhereInput[] | BeforeHolidayRestrictedWhereInput
  >;
}

export interface EmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  rateOfWork_not?: Maybe<Float>;
  rateOfWork_in?: Maybe<Float[] | Float>;
  rateOfWork_not_in?: Maybe<Float[] | Float>;
  rateOfWork_lt?: Maybe<Float>;
  rateOfWork_lte?: Maybe<Float>;
  rateOfWork_gt?: Maybe<Float>;
  rateOfWork_gte?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
  hoursOfMonth_not?: Maybe<String>;
  hoursOfMonth_in?: Maybe<String[] | String>;
  hoursOfMonth_not_in?: Maybe<String[] | String>;
  hoursOfMonth_lt?: Maybe<String>;
  hoursOfMonth_lte?: Maybe<String>;
  hoursOfMonth_gt?: Maybe<String>;
  hoursOfMonth_gte?: Maybe<String>;
  hoursOfMonth_contains?: Maybe<String>;
  hoursOfMonth_not_contains?: Maybe<String>;
  hoursOfMonth_starts_with?: Maybe<String>;
  hoursOfMonth_not_starts_with?: Maybe<String>;
  hoursOfMonth_ends_with?: Maybe<String>;
  hoursOfMonth_not_ends_with?: Maybe<String>;
  positionOfEmployee?: Maybe<PositionOfEmployeeWhereInput>;
  daysOfEmployee_some?: Maybe<DayOfEmployeeWhereInput>;
  daysOfEmployee_every?: Maybe<DayOfEmployeeRestrictedWhereInput>;
  daysOfEmployee_none?: Maybe<DayOfEmployeeRestrictedWhereInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export interface PositionOfEmployeeWhereInput {
  namePosition?: Maybe<String>;
  namePosition_not?: Maybe<String>;
  namePosition_in?: Maybe<String[] | String>;
  namePosition_not_in?: Maybe<String[] | String>;
  namePosition_lt?: Maybe<String>;
  namePosition_lte?: Maybe<String>;
  namePosition_gt?: Maybe<String>;
  namePosition_gte?: Maybe<String>;
  namePosition_contains?: Maybe<String>;
  namePosition_not_contains?: Maybe<String>;
  namePosition_starts_with?: Maybe<String>;
  namePosition_not_starts_with?: Maybe<String>;
  namePosition_ends_with?: Maybe<String>;
  namePosition_not_ends_with?: Maybe<String>;
  hoursOfWork?: Maybe<WorkTimeEWhereInput>;
  secondHoursOfWork?: Maybe<SecondWorkTimeEWhereInput>;
  lunch?: Maybe<LunchTimeEWhereInput>;
  secondLunch?: Maybe<SecondLunchTimeEWhereInput>;
  fulltime?: Maybe<Boolean>;
  fulltime_not?: Maybe<Boolean>;
  longOfDay?: Maybe<String>;
  longOfDay_not?: Maybe<String>;
  longOfDay_in?: Maybe<String[] | String>;
  longOfDay_not_in?: Maybe<String[] | String>;
  longOfDay_lt?: Maybe<String>;
  longOfDay_lte?: Maybe<String>;
  longOfDay_gt?: Maybe<String>;
  longOfDay_gte?: Maybe<String>;
  longOfDay_contains?: Maybe<String>;
  longOfDay_not_contains?: Maybe<String>;
  longOfDay_starts_with?: Maybe<String>;
  longOfDay_not_starts_with?: Maybe<String>;
  longOfDay_ends_with?: Maybe<String>;
  longOfDay_not_ends_with?: Maybe<String>;
  AND?: Maybe<PositionOfEmployeeWhereInput[] | PositionOfEmployeeWhereInput>;
}

export interface WorkTimeEWhereInput {
  startWork?: Maybe<String>;
  startWork_not?: Maybe<String>;
  startWork_in?: Maybe<String[] | String>;
  startWork_not_in?: Maybe<String[] | String>;
  startWork_lt?: Maybe<String>;
  startWork_lte?: Maybe<String>;
  startWork_gt?: Maybe<String>;
  startWork_gte?: Maybe<String>;
  startWork_contains?: Maybe<String>;
  startWork_not_contains?: Maybe<String>;
  startWork_starts_with?: Maybe<String>;
  startWork_not_starts_with?: Maybe<String>;
  startWork_ends_with?: Maybe<String>;
  startWork_not_ends_with?: Maybe<String>;
  endWork?: Maybe<String>;
  endWork_not?: Maybe<String>;
  endWork_in?: Maybe<String[] | String>;
  endWork_not_in?: Maybe<String[] | String>;
  endWork_lt?: Maybe<String>;
  endWork_lte?: Maybe<String>;
  endWork_gt?: Maybe<String>;
  endWork_gte?: Maybe<String>;
  endWork_contains?: Maybe<String>;
  endWork_not_contains?: Maybe<String>;
  endWork_starts_with?: Maybe<String>;
  endWork_not_starts_with?: Maybe<String>;
  endWork_ends_with?: Maybe<String>;
  endWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<WorkTimeEWhereInput[] | WorkTimeEWhereInput>;
}

export interface SecondWorkTimeEWhereInput {
  startSecondWork?: Maybe<String>;
  startSecondWork_not?: Maybe<String>;
  startSecondWork_in?: Maybe<String[] | String>;
  startSecondWork_not_in?: Maybe<String[] | String>;
  startSecondWork_lt?: Maybe<String>;
  startSecondWork_lte?: Maybe<String>;
  startSecondWork_gt?: Maybe<String>;
  startSecondWork_gte?: Maybe<String>;
  startSecondWork_contains?: Maybe<String>;
  startSecondWork_not_contains?: Maybe<String>;
  startSecondWork_starts_with?: Maybe<String>;
  startSecondWork_not_starts_with?: Maybe<String>;
  startSecondWork_ends_with?: Maybe<String>;
  startSecondWork_not_ends_with?: Maybe<String>;
  endSecondWork?: Maybe<String>;
  endSecondWork_not?: Maybe<String>;
  endSecondWork_in?: Maybe<String[] | String>;
  endSecondWork_not_in?: Maybe<String[] | String>;
  endSecondWork_lt?: Maybe<String>;
  endSecondWork_lte?: Maybe<String>;
  endSecondWork_gt?: Maybe<String>;
  endSecondWork_gte?: Maybe<String>;
  endSecondWork_contains?: Maybe<String>;
  endSecondWork_not_contains?: Maybe<String>;
  endSecondWork_starts_with?: Maybe<String>;
  endSecondWork_not_starts_with?: Maybe<String>;
  endSecondWork_ends_with?: Maybe<String>;
  endSecondWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<SecondWorkTimeEWhereInput[] | SecondWorkTimeEWhereInput>;
}

export interface LunchTimeEWhereInput {
  startLunch?: Maybe<String>;
  startLunch_not?: Maybe<String>;
  startLunch_in?: Maybe<String[] | String>;
  startLunch_not_in?: Maybe<String[] | String>;
  startLunch_lt?: Maybe<String>;
  startLunch_lte?: Maybe<String>;
  startLunch_gt?: Maybe<String>;
  startLunch_gte?: Maybe<String>;
  startLunch_contains?: Maybe<String>;
  startLunch_not_contains?: Maybe<String>;
  startLunch_starts_with?: Maybe<String>;
  startLunch_not_starts_with?: Maybe<String>;
  startLunch_ends_with?: Maybe<String>;
  startLunch_not_ends_with?: Maybe<String>;
  endLunch?: Maybe<String>;
  endLunch_not?: Maybe<String>;
  endLunch_in?: Maybe<String[] | String>;
  endLunch_not_in?: Maybe<String[] | String>;
  endLunch_lt?: Maybe<String>;
  endLunch_lte?: Maybe<String>;
  endLunch_gt?: Maybe<String>;
  endLunch_gte?: Maybe<String>;
  endLunch_contains?: Maybe<String>;
  endLunch_not_contains?: Maybe<String>;
  endLunch_starts_with?: Maybe<String>;
  endLunch_not_starts_with?: Maybe<String>;
  endLunch_ends_with?: Maybe<String>;
  endLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<LunchTimeEWhereInput[] | LunchTimeEWhereInput>;
}

export interface SecondLunchTimeEWhereInput {
  startSecondLunch?: Maybe<String>;
  startSecondLunch_not?: Maybe<String>;
  startSecondLunch_in?: Maybe<String[] | String>;
  startSecondLunch_not_in?: Maybe<String[] | String>;
  startSecondLunch_lt?: Maybe<String>;
  startSecondLunch_lte?: Maybe<String>;
  startSecondLunch_gt?: Maybe<String>;
  startSecondLunch_gte?: Maybe<String>;
  startSecondLunch_contains?: Maybe<String>;
  startSecondLunch_not_contains?: Maybe<String>;
  startSecondLunch_starts_with?: Maybe<String>;
  startSecondLunch_not_starts_with?: Maybe<String>;
  startSecondLunch_ends_with?: Maybe<String>;
  startSecondLunch_not_ends_with?: Maybe<String>;
  endSecondLunch?: Maybe<String>;
  endSecondLunch_not?: Maybe<String>;
  endSecondLunch_in?: Maybe<String[] | String>;
  endSecondLunch_not_in?: Maybe<String[] | String>;
  endSecondLunch_lt?: Maybe<String>;
  endSecondLunch_lte?: Maybe<String>;
  endSecondLunch_gt?: Maybe<String>;
  endSecondLunch_gte?: Maybe<String>;
  endSecondLunch_contains?: Maybe<String>;
  endSecondLunch_not_contains?: Maybe<String>;
  endSecondLunch_starts_with?: Maybe<String>;
  endSecondLunch_not_starts_with?: Maybe<String>;
  endSecondLunch_ends_with?: Maybe<String>;
  endSecondLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<SecondLunchTimeEWhereInput[] | SecondLunchTimeEWhereInput>;
}

export interface DayOfEmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStartWork_not?: Maybe<String>;
  firstStartWork_in?: Maybe<String[] | String>;
  firstStartWork_not_in?: Maybe<String[] | String>;
  firstStartWork_lt?: Maybe<String>;
  firstStartWork_lte?: Maybe<String>;
  firstStartWork_gt?: Maybe<String>;
  firstStartWork_gte?: Maybe<String>;
  firstStartWork_contains?: Maybe<String>;
  firstStartWork_not_contains?: Maybe<String>;
  firstStartWork_starts_with?: Maybe<String>;
  firstStartWork_not_starts_with?: Maybe<String>;
  firstStartWork_ends_with?: Maybe<String>;
  firstStartWork_not_ends_with?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  firstStopWork_not?: Maybe<String>;
  firstStopWork_in?: Maybe<String[] | String>;
  firstStopWork_not_in?: Maybe<String[] | String>;
  firstStopWork_lt?: Maybe<String>;
  firstStopWork_lte?: Maybe<String>;
  firstStopWork_gt?: Maybe<String>;
  firstStopWork_gte?: Maybe<String>;
  firstStopWork_contains?: Maybe<String>;
  firstStopWork_not_contains?: Maybe<String>;
  firstStopWork_starts_with?: Maybe<String>;
  firstStopWork_not_starts_with?: Maybe<String>;
  firstStopWork_ends_with?: Maybe<String>;
  firstStopWork_not_ends_with?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStartWork_not?: Maybe<String>;
  secondStartWork_in?: Maybe<String[] | String>;
  secondStartWork_not_in?: Maybe<String[] | String>;
  secondStartWork_lt?: Maybe<String>;
  secondStartWork_lte?: Maybe<String>;
  secondStartWork_gt?: Maybe<String>;
  secondStartWork_gte?: Maybe<String>;
  secondStartWork_contains?: Maybe<String>;
  secondStartWork_not_contains?: Maybe<String>;
  secondStartWork_starts_with?: Maybe<String>;
  secondStartWork_not_starts_with?: Maybe<String>;
  secondStartWork_ends_with?: Maybe<String>;
  secondStartWork_not_ends_with?: Maybe<String>;
  secondStopWork?: Maybe<String>;
  secondStopWork_not?: Maybe<String>;
  secondStopWork_in?: Maybe<String[] | String>;
  secondStopWork_not_in?: Maybe<String[] | String>;
  secondStopWork_lt?: Maybe<String>;
  secondStopWork_lte?: Maybe<String>;
  secondStopWork_gt?: Maybe<String>;
  secondStopWork_gte?: Maybe<String>;
  secondStopWork_contains?: Maybe<String>;
  secondStopWork_not_contains?: Maybe<String>;
  secondStopWork_starts_with?: Maybe<String>;
  secondStopWork_not_starts_with?: Maybe<String>;
  secondStopWork_ends_with?: Maybe<String>;
  secondStopWork_not_ends_with?: Maybe<String>;
  kind?: Maybe<KindWhereInput>;
  AND?: Maybe<DayOfEmployeeWhereInput[] | DayOfEmployeeWhereInput>;
}

export interface KindWhereInput {
  businessTrip?: Maybe<Boolean>;
  businessTrip_not?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  study_not?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  studyAdd_not?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  unknown_not?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  absenteeism_not?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  goverment_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  disease_not?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  vacation_not?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  childCare_not?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  admVacation_not?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  overTime_not?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  nightTime_not?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
  working_not?: Maybe<Boolean>;
  AND?: Maybe<KindWhereInput[] | KindWhereInput>;
}

export interface DayOfEmployeeRestrictedWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStartWork_not?: Maybe<String>;
  firstStartWork_in?: Maybe<String[] | String>;
  firstStartWork_not_in?: Maybe<String[] | String>;
  firstStartWork_lt?: Maybe<String>;
  firstStartWork_lte?: Maybe<String>;
  firstStartWork_gt?: Maybe<String>;
  firstStartWork_gte?: Maybe<String>;
  firstStartWork_contains?: Maybe<String>;
  firstStartWork_not_contains?: Maybe<String>;
  firstStartWork_starts_with?: Maybe<String>;
  firstStartWork_not_starts_with?: Maybe<String>;
  firstStartWork_ends_with?: Maybe<String>;
  firstStartWork_not_ends_with?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  firstStopWork_not?: Maybe<String>;
  firstStopWork_in?: Maybe<String[] | String>;
  firstStopWork_not_in?: Maybe<String[] | String>;
  firstStopWork_lt?: Maybe<String>;
  firstStopWork_lte?: Maybe<String>;
  firstStopWork_gt?: Maybe<String>;
  firstStopWork_gte?: Maybe<String>;
  firstStopWork_contains?: Maybe<String>;
  firstStopWork_not_contains?: Maybe<String>;
  firstStopWork_starts_with?: Maybe<String>;
  firstStopWork_not_starts_with?: Maybe<String>;
  firstStopWork_ends_with?: Maybe<String>;
  firstStopWork_not_ends_with?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStartWork_not?: Maybe<String>;
  secondStartWork_in?: Maybe<String[] | String>;
  secondStartWork_not_in?: Maybe<String[] | String>;
  secondStartWork_lt?: Maybe<String>;
  secondStartWork_lte?: Maybe<String>;
  secondStartWork_gt?: Maybe<String>;
  secondStartWork_gte?: Maybe<String>;
  secondStartWork_contains?: Maybe<String>;
  secondStartWork_not_contains?: Maybe<String>;
  secondStartWork_starts_with?: Maybe<String>;
  secondStartWork_not_starts_with?: Maybe<String>;
  secondStartWork_ends_with?: Maybe<String>;
  secondStartWork_not_ends_with?: Maybe<String>;
  secondStopWork?: Maybe<String>;
  secondStopWork_not?: Maybe<String>;
  secondStopWork_in?: Maybe<String[] | String>;
  secondStopWork_not_in?: Maybe<String[] | String>;
  secondStopWork_lt?: Maybe<String>;
  secondStopWork_lte?: Maybe<String>;
  secondStopWork_gt?: Maybe<String>;
  secondStopWork_gte?: Maybe<String>;
  secondStopWork_contains?: Maybe<String>;
  secondStopWork_not_contains?: Maybe<String>;
  secondStopWork_starts_with?: Maybe<String>;
  secondStopWork_not_starts_with?: Maybe<String>;
  secondStopWork_ends_with?: Maybe<String>;
  secondStopWork_not_ends_with?: Maybe<String>;
  kind?: Maybe<KindRestrictedWhereInput>;
  AND?: Maybe<
    DayOfEmployeeRestrictedWhereInput[] | DayOfEmployeeRestrictedWhereInput
  >;
}

export interface KindRestrictedWhereInput {
  businessTrip?: Maybe<Boolean>;
  businessTrip_not?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  study_not?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  studyAdd_not?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  unknown_not?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  absenteeism_not?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  goverment_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  disease_not?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  vacation_not?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  childCare_not?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  admVacation_not?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  overTime_not?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  nightTime_not?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
  working_not?: Maybe<Boolean>;
  AND?: Maybe<KindRestrictedWhereInput[] | KindRestrictedWhereInput>;
}

export interface EmployeeRestrictedWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  rateOfWork_not?: Maybe<Float>;
  rateOfWork_in?: Maybe<Float[] | Float>;
  rateOfWork_not_in?: Maybe<Float[] | Float>;
  rateOfWork_lt?: Maybe<Float>;
  rateOfWork_lte?: Maybe<Float>;
  rateOfWork_gt?: Maybe<Float>;
  rateOfWork_gte?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
  hoursOfMonth_not?: Maybe<String>;
  hoursOfMonth_in?: Maybe<String[] | String>;
  hoursOfMonth_not_in?: Maybe<String[] | String>;
  hoursOfMonth_lt?: Maybe<String>;
  hoursOfMonth_lte?: Maybe<String>;
  hoursOfMonth_gt?: Maybe<String>;
  hoursOfMonth_gte?: Maybe<String>;
  hoursOfMonth_contains?: Maybe<String>;
  hoursOfMonth_not_contains?: Maybe<String>;
  hoursOfMonth_starts_with?: Maybe<String>;
  hoursOfMonth_not_starts_with?: Maybe<String>;
  hoursOfMonth_ends_with?: Maybe<String>;
  hoursOfMonth_not_ends_with?: Maybe<String>;
  positionOfEmployee?: Maybe<PositionOfEmployeeRestrictedWhereInput>;
  daysOfEmployee_every?: Maybe<DayOfEmployeeRestrictedWhereInput>;
  daysOfEmployee_some?: Maybe<DayOfEmployeeRestrictedWhereInput>;
  daysOfEmployee_none?: Maybe<DayOfEmployeeRestrictedWhereInput>;
  AND?: Maybe<EmployeeRestrictedWhereInput[] | EmployeeRestrictedWhereInput>;
}

export interface PositionOfEmployeeRestrictedWhereInput {
  namePosition?: Maybe<String>;
  namePosition_not?: Maybe<String>;
  namePosition_in?: Maybe<String[] | String>;
  namePosition_not_in?: Maybe<String[] | String>;
  namePosition_lt?: Maybe<String>;
  namePosition_lte?: Maybe<String>;
  namePosition_gt?: Maybe<String>;
  namePosition_gte?: Maybe<String>;
  namePosition_contains?: Maybe<String>;
  namePosition_not_contains?: Maybe<String>;
  namePosition_starts_with?: Maybe<String>;
  namePosition_not_starts_with?: Maybe<String>;
  namePosition_ends_with?: Maybe<String>;
  namePosition_not_ends_with?: Maybe<String>;
  hoursOfWork?: Maybe<WorkTimeERestrictedWhereInput>;
  secondHoursOfWork?: Maybe<SecondWorkTimeERestrictedWhereInput>;
  lunch?: Maybe<LunchTimeERestrictedWhereInput>;
  secondLunch?: Maybe<SecondLunchTimeERestrictedWhereInput>;
  fulltime?: Maybe<Boolean>;
  fulltime_not?: Maybe<Boolean>;
  longOfDay?: Maybe<String>;
  longOfDay_not?: Maybe<String>;
  longOfDay_in?: Maybe<String[] | String>;
  longOfDay_not_in?: Maybe<String[] | String>;
  longOfDay_lt?: Maybe<String>;
  longOfDay_lte?: Maybe<String>;
  longOfDay_gt?: Maybe<String>;
  longOfDay_gte?: Maybe<String>;
  longOfDay_contains?: Maybe<String>;
  longOfDay_not_contains?: Maybe<String>;
  longOfDay_starts_with?: Maybe<String>;
  longOfDay_not_starts_with?: Maybe<String>;
  longOfDay_ends_with?: Maybe<String>;
  longOfDay_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | PositionOfEmployeeRestrictedWhereInput[]
    | PositionOfEmployeeRestrictedWhereInput
  >;
}

export interface WorkTimeERestrictedWhereInput {
  startWork?: Maybe<String>;
  startWork_not?: Maybe<String>;
  startWork_in?: Maybe<String[] | String>;
  startWork_not_in?: Maybe<String[] | String>;
  startWork_lt?: Maybe<String>;
  startWork_lte?: Maybe<String>;
  startWork_gt?: Maybe<String>;
  startWork_gte?: Maybe<String>;
  startWork_contains?: Maybe<String>;
  startWork_not_contains?: Maybe<String>;
  startWork_starts_with?: Maybe<String>;
  startWork_not_starts_with?: Maybe<String>;
  startWork_ends_with?: Maybe<String>;
  startWork_not_ends_with?: Maybe<String>;
  endWork?: Maybe<String>;
  endWork_not?: Maybe<String>;
  endWork_in?: Maybe<String[] | String>;
  endWork_not_in?: Maybe<String[] | String>;
  endWork_lt?: Maybe<String>;
  endWork_lte?: Maybe<String>;
  endWork_gt?: Maybe<String>;
  endWork_gte?: Maybe<String>;
  endWork_contains?: Maybe<String>;
  endWork_not_contains?: Maybe<String>;
  endWork_starts_with?: Maybe<String>;
  endWork_not_starts_with?: Maybe<String>;
  endWork_ends_with?: Maybe<String>;
  endWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<WorkTimeERestrictedWhereInput[] | WorkTimeERestrictedWhereInput>;
}

export interface SecondWorkTimeERestrictedWhereInput {
  startSecondWork?: Maybe<String>;
  startSecondWork_not?: Maybe<String>;
  startSecondWork_in?: Maybe<String[] | String>;
  startSecondWork_not_in?: Maybe<String[] | String>;
  startSecondWork_lt?: Maybe<String>;
  startSecondWork_lte?: Maybe<String>;
  startSecondWork_gt?: Maybe<String>;
  startSecondWork_gte?: Maybe<String>;
  startSecondWork_contains?: Maybe<String>;
  startSecondWork_not_contains?: Maybe<String>;
  startSecondWork_starts_with?: Maybe<String>;
  startSecondWork_not_starts_with?: Maybe<String>;
  startSecondWork_ends_with?: Maybe<String>;
  startSecondWork_not_ends_with?: Maybe<String>;
  endSecondWork?: Maybe<String>;
  endSecondWork_not?: Maybe<String>;
  endSecondWork_in?: Maybe<String[] | String>;
  endSecondWork_not_in?: Maybe<String[] | String>;
  endSecondWork_lt?: Maybe<String>;
  endSecondWork_lte?: Maybe<String>;
  endSecondWork_gt?: Maybe<String>;
  endSecondWork_gte?: Maybe<String>;
  endSecondWork_contains?: Maybe<String>;
  endSecondWork_not_contains?: Maybe<String>;
  endSecondWork_starts_with?: Maybe<String>;
  endSecondWork_not_starts_with?: Maybe<String>;
  endSecondWork_ends_with?: Maybe<String>;
  endSecondWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    SecondWorkTimeERestrictedWhereInput[] | SecondWorkTimeERestrictedWhereInput
  >;
}

export interface LunchTimeERestrictedWhereInput {
  startLunch?: Maybe<String>;
  startLunch_not?: Maybe<String>;
  startLunch_in?: Maybe<String[] | String>;
  startLunch_not_in?: Maybe<String[] | String>;
  startLunch_lt?: Maybe<String>;
  startLunch_lte?: Maybe<String>;
  startLunch_gt?: Maybe<String>;
  startLunch_gte?: Maybe<String>;
  startLunch_contains?: Maybe<String>;
  startLunch_not_contains?: Maybe<String>;
  startLunch_starts_with?: Maybe<String>;
  startLunch_not_starts_with?: Maybe<String>;
  startLunch_ends_with?: Maybe<String>;
  startLunch_not_ends_with?: Maybe<String>;
  endLunch?: Maybe<String>;
  endLunch_not?: Maybe<String>;
  endLunch_in?: Maybe<String[] | String>;
  endLunch_not_in?: Maybe<String[] | String>;
  endLunch_lt?: Maybe<String>;
  endLunch_lte?: Maybe<String>;
  endLunch_gt?: Maybe<String>;
  endLunch_gte?: Maybe<String>;
  endLunch_contains?: Maybe<String>;
  endLunch_not_contains?: Maybe<String>;
  endLunch_starts_with?: Maybe<String>;
  endLunch_not_starts_with?: Maybe<String>;
  endLunch_ends_with?: Maybe<String>;
  endLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    LunchTimeERestrictedWhereInput[] | LunchTimeERestrictedWhereInput
  >;
}

export interface SecondLunchTimeERestrictedWhereInput {
  startSecondLunch?: Maybe<String>;
  startSecondLunch_not?: Maybe<String>;
  startSecondLunch_in?: Maybe<String[] | String>;
  startSecondLunch_not_in?: Maybe<String[] | String>;
  startSecondLunch_lt?: Maybe<String>;
  startSecondLunch_lte?: Maybe<String>;
  startSecondLunch_gt?: Maybe<String>;
  startSecondLunch_gte?: Maybe<String>;
  startSecondLunch_contains?: Maybe<String>;
  startSecondLunch_not_contains?: Maybe<String>;
  startSecondLunch_starts_with?: Maybe<String>;
  startSecondLunch_not_starts_with?: Maybe<String>;
  startSecondLunch_ends_with?: Maybe<String>;
  startSecondLunch_not_ends_with?: Maybe<String>;
  endSecondLunch?: Maybe<String>;
  endSecondLunch_not?: Maybe<String>;
  endSecondLunch_in?: Maybe<String[] | String>;
  endSecondLunch_not_in?: Maybe<String[] | String>;
  endSecondLunch_lt?: Maybe<String>;
  endSecondLunch_lte?: Maybe<String>;
  endSecondLunch_gt?: Maybe<String>;
  endSecondLunch_gte?: Maybe<String>;
  endSecondLunch_contains?: Maybe<String>;
  endSecondLunch_not_contains?: Maybe<String>;
  endSecondLunch_starts_with?: Maybe<String>;
  endSecondLunch_not_starts_with?: Maybe<String>;
  endSecondLunch_ends_with?: Maybe<String>;
  endSecondLunch_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | SecondLunchTimeERestrictedWhereInput[]
    | SecondLunchTimeERestrictedWhereInput
  >;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AdminCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  language?: Maybe<String>;
  schedules?: Maybe<ScheduleCreateManyWithoutOwnerInput>;
  users?: Maybe<UserCreateManyWithoutOwnerInput>;
}

export interface ScheduleCreateManyWithoutOwnerInput {
  create?: Maybe<
    ScheduleCreateWithoutOwnerInput[] | ScheduleCreateWithoutOwnerInput
  >;
  connect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
}

export interface ScheduleCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  nameSchedule: String;
  year: Int;
  month: MonthCreateOneInput;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek: Float;
  theader?: Maybe<String>;
  employees?: Maybe<EmployeeCreateManyInput>;
}

export interface MonthCreateOneInput {
  create?: Maybe<MonthCreateInput>;
}

export interface MonthCreateInput {
  id?: Maybe<ID_Input>;
  days?: Maybe<DayCreateManyInput>;
  nameOfMonth: String;
  daysAmount: Int;
  weekdays?: Maybe<WeekdayCreateManyInput>;
  weekends?: Maybe<WeekendCreateManyInput>;
  holidays?: Maybe<HolidayCreateManyInput>;
  beforeHolidays?: Maybe<BeforeHolidayCreateManyInput>;
}

export interface DayCreateManyInput {
  create?: Maybe<DayCreateInput[] | DayCreateInput>;
}

export interface DayCreateInput {
  id?: Maybe<ID_Input>;
  number: Int;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  kindOfDay?: Maybe<KindOfDayCreateOneInput>;
}

export interface KindOfDayCreateOneInput {
  create?: Maybe<KindOfDayCreateInput>;
}

export interface KindOfDayCreateInput {
  businessTrip?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
}

export interface WeekdayCreateManyInput {
  create?: Maybe<WeekdayCreateInput[] | WeekdayCreateInput>;
}

export interface WeekdayCreateInput {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface WeekendCreateManyInput {
  create?: Maybe<WeekendCreateInput[] | WeekendCreateInput>;
}

export interface WeekendCreateInput {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface HolidayCreateManyInput {
  create?: Maybe<HolidayCreateInput[] | HolidayCreateInput>;
}

export interface HolidayCreateInput {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface BeforeHolidayCreateManyInput {
  create?: Maybe<BeforeHolidayCreateInput[] | BeforeHolidayCreateInput>;
}

export interface BeforeHolidayCreateInput {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface EmployeeCreateManyInput {
  create?: Maybe<EmployeeCreateInput[] | EmployeeCreateInput>;
}

export interface EmployeeCreateInput {
  id?: Maybe<ID_Input>;
  fullname: String;
  rateOfWork?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
  positionOfEmployee: PositionOfEmployeeCreateOneInput;
  daysOfEmployee?: Maybe<DayOfEmployeeCreateManyInput>;
}

export interface PositionOfEmployeeCreateOneInput {
  create?: Maybe<PositionOfEmployeeCreateInput>;
}

export interface PositionOfEmployeeCreateInput {
  namePosition: String;
  hoursOfWork: WorkTimeECreateOneInput;
  secondHoursOfWork?: Maybe<SecondWorkTimeECreateOneInput>;
  lunch?: Maybe<LunchTimeECreateOneInput>;
  secondLunch?: Maybe<SecondLunchTimeECreateOneInput>;
  fulltime?: Maybe<Boolean>;
  longOfDay: String;
}

export interface WorkTimeECreateOneInput {
  create?: Maybe<WorkTimeECreateInput>;
}

export interface WorkTimeECreateInput {
  startWork: String;
  endWork: String;
}

export interface SecondWorkTimeECreateOneInput {
  create?: Maybe<SecondWorkTimeECreateInput>;
}

export interface SecondWorkTimeECreateInput {
  startSecondWork: String;
  endSecondWork: String;
}

export interface LunchTimeECreateOneInput {
  create?: Maybe<LunchTimeECreateInput>;
}

export interface LunchTimeECreateInput {
  startLunch: String;
  endLunch: String;
}

export interface SecondLunchTimeECreateOneInput {
  create?: Maybe<SecondLunchTimeECreateInput>;
}

export interface SecondLunchTimeECreateInput {
  startSecondLunch: String;
  endSecondLunch: String;
}

export interface DayOfEmployeeCreateManyInput {
  create?: Maybe<DayOfEmployeeCreateInput[] | DayOfEmployeeCreateInput>;
}

export interface DayOfEmployeeCreateInput {
  id?: Maybe<ID_Input>;
  number: Int;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStopWork?: Maybe<String>;
  kind: KindCreateOneInput;
}

export interface KindCreateOneInput {
  create?: Maybe<KindCreateInput>;
}

export interface KindCreateInput {
  businessTrip?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
}

export interface UserCreateManyWithoutOwnerInput {
  create?: Maybe<UserCreateWithoutOwnerInput[] | UserCreateWithoutOwnerInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  fullname: String;
  position: PositionCreateOneInput;
  rateOfWork?: Maybe<Float>;
}

export interface PositionCreateOneInput {
  create?: Maybe<PositionCreateInput>;
}

export interface PositionCreateInput {
  namePosition: String;
  hoursOfWork: WorkTimeCreateOneInput;
  secondHoursOfWork?: Maybe<SecondWorkTimeCreateOneInput>;
  lunch?: Maybe<LunchTimeCreateOneInput>;
  secondLunch?: Maybe<SecondLunchTimeCreateOneInput>;
  fulltime?: Maybe<Boolean>;
  longOfDay: String;
  hoursOfMonth?: Maybe<String>;
}

export interface WorkTimeCreateOneInput {
  create?: Maybe<WorkTimeCreateInput>;
}

export interface WorkTimeCreateInput {
  startWork: String;
  endWork: String;
}

export interface SecondWorkTimeCreateOneInput {
  create?: Maybe<SecondWorkTimeCreateInput>;
}

export interface SecondWorkTimeCreateInput {
  startSecondWork: String;
  endSecondWork: String;
}

export interface LunchTimeCreateOneInput {
  create?: Maybe<LunchTimeCreateInput>;
}

export interface LunchTimeCreateInput {
  startLunch: String;
  endLunch: String;
}

export interface SecondLunchTimeCreateOneInput {
  create?: Maybe<SecondLunchTimeCreateInput>;
}

export interface SecondLunchTimeCreateInput {
  startSecondLunch: String;
  endSecondLunch: String;
}

export interface AdminUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  language?: Maybe<String>;
  schedules?: Maybe<ScheduleUpdateManyWithoutOwnerInput>;
  users?: Maybe<UserUpdateManyWithoutOwnerInput>;
}

export interface ScheduleUpdateManyWithoutOwnerInput {
  create?: Maybe<
    ScheduleCreateWithoutOwnerInput[] | ScheduleCreateWithoutOwnerInput
  >;
  delete?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  connect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  set?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  disconnect?: Maybe<ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput>;
  update?: Maybe<
    | ScheduleUpdateWithWhereUniqueWithoutOwnerInput[]
    | ScheduleUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | ScheduleUpsertWithWhereUniqueWithoutOwnerInput[]
    | ScheduleUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  updateMany?: Maybe<
    | ScheduleUpdateManyWithWhereNestedInput[]
    | ScheduleUpdateManyWithWhereNestedInput
  >;
}

export interface ScheduleUpdateWithWhereUniqueWithoutOwnerInput {
  where: ScheduleWhereUniqueInput;
  data: ScheduleUpdateWithoutOwnerDataInput;
}

export interface ScheduleUpdateWithoutOwnerDataInput {
  nameSchedule?: Maybe<String>;
  year?: Maybe<Int>;
  month?: Maybe<MonthUpdateOneRequiredInput>;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  theader?: Maybe<String>;
  employees?: Maybe<EmployeeUpdateManyInput>;
}

export interface MonthUpdateOneRequiredInput {
  create?: Maybe<MonthCreateInput>;
  update?: Maybe<MonthUpdateDataInput>;
  upsert?: Maybe<MonthUpsertNestedInput>;
  connect?: Maybe<MonthWhereUniqueInput>;
}

export interface MonthUpdateDataInput {
  days?: Maybe<DayUpdateManyInput>;
  nameOfMonth?: Maybe<String>;
  daysAmount?: Maybe<Int>;
  weekdays?: Maybe<WeekdayUpdateManyInput>;
  weekends?: Maybe<WeekendUpdateManyInput>;
  holidays?: Maybe<HolidayUpdateManyInput>;
  beforeHolidays?: Maybe<BeforeHolidayUpdateManyInput>;
}

export interface DayUpdateManyInput {
  create?: Maybe<DayCreateInput[] | DayCreateInput>;
  update?: Maybe<
    DayUpdateWithWhereUniqueNestedInput[] | DayUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    DayUpsertWithWhereUniqueNestedInput[] | DayUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<DayWhereUniqueInput[] | DayWhereUniqueInput>;
  deleteMany?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  updateMany?: Maybe<
    DayUpdateManyWithWhereNestedInput[] | DayUpdateManyWithWhereNestedInput
  >;
}

export interface DayUpdateWithWhereUniqueNestedInput {
  where: DayWhereUniqueInput;
  data: DayUpdateDataInput;
}

export type DayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DayUpdateDataInput {
  number?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  kindOfDay?: Maybe<KindOfDayUpdateOneInput>;
}

export interface KindOfDayUpdateOneInput {
  create?: Maybe<KindOfDayCreateInput>;
  update?: Maybe<KindOfDayUpdateDataInput>;
  upsert?: Maybe<KindOfDayUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface KindOfDayUpdateDataInput {
  businessTrip?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
}

export interface KindOfDayUpsertNestedInput {
  update: KindOfDayUpdateDataInput;
  create: KindOfDayCreateInput;
}

export interface DayUpsertWithWhereUniqueNestedInput {
  where: DayWhereUniqueInput;
  update: DayUpdateDataInput;
  create: DayCreateInput;
}

export interface DayScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  AND?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  OR?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
  NOT?: Maybe<DayScalarWhereInput[] | DayScalarWhereInput>;
}

export interface DayUpdateManyWithWhereNestedInput {
  where: DayScalarWhereInput;
  data: DayUpdateManyDataInput;
}

export interface DayUpdateManyDataInput {
  number?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
}

export interface WeekdayUpdateManyInput {
  create?: Maybe<WeekdayCreateInput[] | WeekdayCreateInput>;
  deleteMany?: Maybe<WeekdayScalarWhereInput[] | WeekdayScalarWhereInput>;
  updateMany?: Maybe<
    | WeekdayUpdateManyWithWhereNestedInput[]
    | WeekdayUpdateManyWithWhereNestedInput
  >;
}

export interface WeekdayScalarWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekdayScalarWhereInput[] | WeekdayScalarWhereInput>;
  OR?: Maybe<WeekdayScalarWhereInput[] | WeekdayScalarWhereInput>;
  NOT?: Maybe<WeekdayScalarWhereInput[] | WeekdayScalarWhereInput>;
}

export interface WeekdayUpdateManyWithWhereNestedInput {
  where: WeekdayScalarWhereInput;
  data: WeekdayUpdateManyDataInput;
}

export interface WeekdayUpdateManyDataInput {
  num?: Maybe<Int>;
  id?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
}

export interface WeekendUpdateManyInput {
  create?: Maybe<WeekendCreateInput[] | WeekendCreateInput>;
  deleteMany?: Maybe<WeekendScalarWhereInput[] | WeekendScalarWhereInput>;
  updateMany?: Maybe<
    | WeekendUpdateManyWithWhereNestedInput[]
    | WeekendUpdateManyWithWhereNestedInput
  >;
}

export interface WeekendScalarWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<WeekendScalarWhereInput[] | WeekendScalarWhereInput>;
  OR?: Maybe<WeekendScalarWhereInput[] | WeekendScalarWhereInput>;
  NOT?: Maybe<WeekendScalarWhereInput[] | WeekendScalarWhereInput>;
}

export interface WeekendUpdateManyWithWhereNestedInput {
  where: WeekendScalarWhereInput;
  data: WeekendUpdateManyDataInput;
}

export interface WeekendUpdateManyDataInput {
  num?: Maybe<Int>;
  id?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
}

export interface HolidayUpdateManyInput {
  create?: Maybe<HolidayCreateInput[] | HolidayCreateInput>;
  deleteMany?: Maybe<HolidayScalarWhereInput[] | HolidayScalarWhereInput>;
  updateMany?: Maybe<
    | HolidayUpdateManyWithWhereNestedInput[]
    | HolidayUpdateManyWithWhereNestedInput
  >;
}

export interface HolidayScalarWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<HolidayScalarWhereInput[] | HolidayScalarWhereInput>;
  OR?: Maybe<HolidayScalarWhereInput[] | HolidayScalarWhereInput>;
  NOT?: Maybe<HolidayScalarWhereInput[] | HolidayScalarWhereInput>;
}

export interface HolidayUpdateManyWithWhereNestedInput {
  where: HolidayScalarWhereInput;
  data: HolidayUpdateManyDataInput;
}

export interface HolidayUpdateManyDataInput {
  num?: Maybe<Int>;
  id?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
}

export interface BeforeHolidayUpdateManyInput {
  create?: Maybe<BeforeHolidayCreateInput[] | BeforeHolidayCreateInput>;
  deleteMany?: Maybe<
    BeforeHolidayScalarWhereInput[] | BeforeHolidayScalarWhereInput
  >;
  updateMany?: Maybe<
    | BeforeHolidayUpdateManyWithWhereNestedInput[]
    | BeforeHolidayUpdateManyWithWhereNestedInput
  >;
}

export interface BeforeHolidayScalarWhereInput {
  num?: Maybe<Int>;
  num_not?: Maybe<Int>;
  num_in?: Maybe<Int[] | Int>;
  num_not_in?: Maybe<Int[] | Int>;
  num_lt?: Maybe<Int>;
  num_lte?: Maybe<Int>;
  num_gt?: Maybe<Int>;
  num_gte?: Maybe<Int>;
  id?: Maybe<String>;
  id_not?: Maybe<String>;
  id_in?: Maybe<String[] | String>;
  id_not_in?: Maybe<String[] | String>;
  id_lt?: Maybe<String>;
  id_lte?: Maybe<String>;
  id_gt?: Maybe<String>;
  id_gte?: Maybe<String>;
  id_contains?: Maybe<String>;
  id_not_contains?: Maybe<String>;
  id_starts_with?: Maybe<String>;
  id_not_starts_with?: Maybe<String>;
  id_ends_with?: Maybe<String>;
  id_not_ends_with?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
  isChecked_not?: Maybe<Boolean>;
  AND?: Maybe<BeforeHolidayScalarWhereInput[] | BeforeHolidayScalarWhereInput>;
  OR?: Maybe<BeforeHolidayScalarWhereInput[] | BeforeHolidayScalarWhereInput>;
  NOT?: Maybe<BeforeHolidayScalarWhereInput[] | BeforeHolidayScalarWhereInput>;
}

export interface BeforeHolidayUpdateManyWithWhereNestedInput {
  where: BeforeHolidayScalarWhereInput;
  data: BeforeHolidayUpdateManyDataInput;
}

export interface BeforeHolidayUpdateManyDataInput {
  num?: Maybe<Int>;
  id?: Maybe<String>;
  isChecked?: Maybe<Boolean>;
}

export interface MonthUpsertNestedInput {
  update: MonthUpdateDataInput;
  create: MonthCreateInput;
}

export type MonthWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EmployeeUpdateManyInput {
  create?: Maybe<EmployeeCreateInput[] | EmployeeCreateInput>;
  update?: Maybe<
    | EmployeeUpdateWithWhereUniqueNestedInput[]
    | EmployeeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | EmployeeUpsertWithWhereUniqueNestedInput[]
    | EmployeeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput>;
  deleteMany?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  updateMany?: Maybe<
    | EmployeeUpdateManyWithWhereNestedInput[]
    | EmployeeUpdateManyWithWhereNestedInput
  >;
}

export interface EmployeeUpdateWithWhereUniqueNestedInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateDataInput;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EmployeeUpdateDataInput {
  fullname?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
  positionOfEmployee?: Maybe<PositionOfEmployeeUpdateOneRequiredInput>;
  daysOfEmployee?: Maybe<DayOfEmployeeUpdateManyInput>;
}

export interface PositionOfEmployeeUpdateOneRequiredInput {
  create?: Maybe<PositionOfEmployeeCreateInput>;
  update?: Maybe<PositionOfEmployeeUpdateDataInput>;
  upsert?: Maybe<PositionOfEmployeeUpsertNestedInput>;
}

export interface PositionOfEmployeeUpdateDataInput {
  namePosition?: Maybe<String>;
  hoursOfWork?: Maybe<WorkTimeEUpdateOneRequiredInput>;
  secondHoursOfWork?: Maybe<SecondWorkTimeEUpdateOneInput>;
  lunch?: Maybe<LunchTimeEUpdateOneInput>;
  secondLunch?: Maybe<SecondLunchTimeEUpdateOneInput>;
  fulltime?: Maybe<Boolean>;
  longOfDay?: Maybe<String>;
}

export interface WorkTimeEUpdateOneRequiredInput {
  create?: Maybe<WorkTimeECreateInput>;
  update?: Maybe<WorkTimeEUpdateDataInput>;
  upsert?: Maybe<WorkTimeEUpsertNestedInput>;
}

export interface WorkTimeEUpdateDataInput {
  startWork?: Maybe<String>;
  endWork?: Maybe<String>;
}

export interface WorkTimeEUpsertNestedInput {
  update: WorkTimeEUpdateDataInput;
  create: WorkTimeECreateInput;
}

export interface SecondWorkTimeEUpdateOneInput {
  create?: Maybe<SecondWorkTimeECreateInput>;
  update?: Maybe<SecondWorkTimeEUpdateDataInput>;
  upsert?: Maybe<SecondWorkTimeEUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SecondWorkTimeEUpdateDataInput {
  startSecondWork?: Maybe<String>;
  endSecondWork?: Maybe<String>;
}

export interface SecondWorkTimeEUpsertNestedInput {
  update: SecondWorkTimeEUpdateDataInput;
  create: SecondWorkTimeECreateInput;
}

export interface LunchTimeEUpdateOneInput {
  create?: Maybe<LunchTimeECreateInput>;
  update?: Maybe<LunchTimeEUpdateDataInput>;
  upsert?: Maybe<LunchTimeEUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface LunchTimeEUpdateDataInput {
  startLunch?: Maybe<String>;
  endLunch?: Maybe<String>;
}

export interface LunchTimeEUpsertNestedInput {
  update: LunchTimeEUpdateDataInput;
  create: LunchTimeECreateInput;
}

export interface SecondLunchTimeEUpdateOneInput {
  create?: Maybe<SecondLunchTimeECreateInput>;
  update?: Maybe<SecondLunchTimeEUpdateDataInput>;
  upsert?: Maybe<SecondLunchTimeEUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SecondLunchTimeEUpdateDataInput {
  startSecondLunch?: Maybe<String>;
  endSecondLunch?: Maybe<String>;
}

export interface SecondLunchTimeEUpsertNestedInput {
  update: SecondLunchTimeEUpdateDataInput;
  create: SecondLunchTimeECreateInput;
}

export interface PositionOfEmployeeUpsertNestedInput {
  update: PositionOfEmployeeUpdateDataInput;
  create: PositionOfEmployeeCreateInput;
}

export interface DayOfEmployeeUpdateManyInput {
  create?: Maybe<DayOfEmployeeCreateInput[] | DayOfEmployeeCreateInput>;
  update?: Maybe<
    | DayOfEmployeeUpdateWithWhereUniqueNestedInput[]
    | DayOfEmployeeUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | DayOfEmployeeUpsertWithWhereUniqueNestedInput[]
    | DayOfEmployeeUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    DayOfEmployeeWhereUniqueInput[] | DayOfEmployeeWhereUniqueInput
  >;
  deleteMany?: Maybe<
    DayOfEmployeeScalarWhereInput[] | DayOfEmployeeScalarWhereInput
  >;
  updateMany?: Maybe<
    | DayOfEmployeeUpdateManyWithWhereNestedInput[]
    | DayOfEmployeeUpdateManyWithWhereNestedInput
  >;
}

export interface DayOfEmployeeUpdateWithWhereUniqueNestedInput {
  where: DayOfEmployeeWhereUniqueInput;
  data: DayOfEmployeeUpdateDataInput;
}

export type DayOfEmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DayOfEmployeeUpdateDataInput {
  number?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStopWork?: Maybe<String>;
  kind?: Maybe<KindUpdateOneRequiredInput>;
}

export interface KindUpdateOneRequiredInput {
  create?: Maybe<KindCreateInput>;
  update?: Maybe<KindUpdateDataInput>;
  upsert?: Maybe<KindUpsertNestedInput>;
}

export interface KindUpdateDataInput {
  businessTrip?: Maybe<Boolean>;
  study?: Maybe<Boolean>;
  studyAdd?: Maybe<Boolean>;
  unknown?: Maybe<Boolean>;
  absenteeism?: Maybe<Boolean>;
  goverment?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  disease?: Maybe<Boolean>;
  vacation?: Maybe<Boolean>;
  childCare?: Maybe<Boolean>;
  admVacation?: Maybe<Boolean>;
  overTime?: Maybe<Boolean>;
  nightTime?: Maybe<Boolean>;
  working?: Maybe<Boolean>;
}

export interface KindUpsertNestedInput {
  update: KindUpdateDataInput;
  create: KindCreateInput;
}

export interface DayOfEmployeeUpsertWithWhereUniqueNestedInput {
  where: DayOfEmployeeWhereUniqueInput;
  update: DayOfEmployeeUpdateDataInput;
  create: DayOfEmployeeCreateInput;
}

export interface DayOfEmployeeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekday_not?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  weekend_not?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  holiday_not?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  beforeHoliday_not?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStartWork_not?: Maybe<String>;
  firstStartWork_in?: Maybe<String[] | String>;
  firstStartWork_not_in?: Maybe<String[] | String>;
  firstStartWork_lt?: Maybe<String>;
  firstStartWork_lte?: Maybe<String>;
  firstStartWork_gt?: Maybe<String>;
  firstStartWork_gte?: Maybe<String>;
  firstStartWork_contains?: Maybe<String>;
  firstStartWork_not_contains?: Maybe<String>;
  firstStartWork_starts_with?: Maybe<String>;
  firstStartWork_not_starts_with?: Maybe<String>;
  firstStartWork_ends_with?: Maybe<String>;
  firstStartWork_not_ends_with?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  firstStopWork_not?: Maybe<String>;
  firstStopWork_in?: Maybe<String[] | String>;
  firstStopWork_not_in?: Maybe<String[] | String>;
  firstStopWork_lt?: Maybe<String>;
  firstStopWork_lte?: Maybe<String>;
  firstStopWork_gt?: Maybe<String>;
  firstStopWork_gte?: Maybe<String>;
  firstStopWork_contains?: Maybe<String>;
  firstStopWork_not_contains?: Maybe<String>;
  firstStopWork_starts_with?: Maybe<String>;
  firstStopWork_not_starts_with?: Maybe<String>;
  firstStopWork_ends_with?: Maybe<String>;
  firstStopWork_not_ends_with?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStartWork_not?: Maybe<String>;
  secondStartWork_in?: Maybe<String[] | String>;
  secondStartWork_not_in?: Maybe<String[] | String>;
  secondStartWork_lt?: Maybe<String>;
  secondStartWork_lte?: Maybe<String>;
  secondStartWork_gt?: Maybe<String>;
  secondStartWork_gte?: Maybe<String>;
  secondStartWork_contains?: Maybe<String>;
  secondStartWork_not_contains?: Maybe<String>;
  secondStartWork_starts_with?: Maybe<String>;
  secondStartWork_not_starts_with?: Maybe<String>;
  secondStartWork_ends_with?: Maybe<String>;
  secondStartWork_not_ends_with?: Maybe<String>;
  secondStopWork?: Maybe<String>;
  secondStopWork_not?: Maybe<String>;
  secondStopWork_in?: Maybe<String[] | String>;
  secondStopWork_not_in?: Maybe<String[] | String>;
  secondStopWork_lt?: Maybe<String>;
  secondStopWork_lte?: Maybe<String>;
  secondStopWork_gt?: Maybe<String>;
  secondStopWork_gte?: Maybe<String>;
  secondStopWork_contains?: Maybe<String>;
  secondStopWork_not_contains?: Maybe<String>;
  secondStopWork_starts_with?: Maybe<String>;
  secondStopWork_not_starts_with?: Maybe<String>;
  secondStopWork_ends_with?: Maybe<String>;
  secondStopWork_not_ends_with?: Maybe<String>;
  AND?: Maybe<DayOfEmployeeScalarWhereInput[] | DayOfEmployeeScalarWhereInput>;
  OR?: Maybe<DayOfEmployeeScalarWhereInput[] | DayOfEmployeeScalarWhereInput>;
  NOT?: Maybe<DayOfEmployeeScalarWhereInput[] | DayOfEmployeeScalarWhereInput>;
}

export interface DayOfEmployeeUpdateManyWithWhereNestedInput {
  where: DayOfEmployeeScalarWhereInput;
  data: DayOfEmployeeUpdateManyDataInput;
}

export interface DayOfEmployeeUpdateManyDataInput {
  number?: Maybe<Int>;
  weekday?: Maybe<Boolean>;
  weekend?: Maybe<Boolean>;
  holiday?: Maybe<Boolean>;
  beforeHoliday?: Maybe<Boolean>;
  firstStartWork?: Maybe<String>;
  firstStopWork?: Maybe<String>;
  secondStartWork?: Maybe<String>;
  secondStopWork?: Maybe<String>;
}

export interface EmployeeUpsertWithWhereUniqueNestedInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface EmployeeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  rateOfWork_not?: Maybe<Float>;
  rateOfWork_in?: Maybe<Float[] | Float>;
  rateOfWork_not_in?: Maybe<Float[] | Float>;
  rateOfWork_lt?: Maybe<Float>;
  rateOfWork_lte?: Maybe<Float>;
  rateOfWork_gt?: Maybe<Float>;
  rateOfWork_gte?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
  hoursOfMonth_not?: Maybe<String>;
  hoursOfMonth_in?: Maybe<String[] | String>;
  hoursOfMonth_not_in?: Maybe<String[] | String>;
  hoursOfMonth_lt?: Maybe<String>;
  hoursOfMonth_lte?: Maybe<String>;
  hoursOfMonth_gt?: Maybe<String>;
  hoursOfMonth_gte?: Maybe<String>;
  hoursOfMonth_contains?: Maybe<String>;
  hoursOfMonth_not_contains?: Maybe<String>;
  hoursOfMonth_starts_with?: Maybe<String>;
  hoursOfMonth_not_starts_with?: Maybe<String>;
  hoursOfMonth_ends_with?: Maybe<String>;
  hoursOfMonth_not_ends_with?: Maybe<String>;
  AND?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  OR?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
  NOT?: Maybe<EmployeeScalarWhereInput[] | EmployeeScalarWhereInput>;
}

export interface EmployeeUpdateManyWithWhereNestedInput {
  where: EmployeeScalarWhereInput;
  data: EmployeeUpdateManyDataInput;
}

export interface EmployeeUpdateManyDataInput {
  fullname?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  hoursOfMonth?: Maybe<String>;
}

export interface ScheduleUpsertWithWhereUniqueWithoutOwnerInput {
  where: ScheduleWhereUniqueInput;
  update: ScheduleUpdateWithoutOwnerDataInput;
  create: ScheduleCreateWithoutOwnerInput;
}

export interface ScheduleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  nameSchedule?: Maybe<String>;
  nameSchedule_not?: Maybe<String>;
  nameSchedule_in?: Maybe<String[] | String>;
  nameSchedule_not_in?: Maybe<String[] | String>;
  nameSchedule_lt?: Maybe<String>;
  nameSchedule_lte?: Maybe<String>;
  nameSchedule_gt?: Maybe<String>;
  nameSchedule_gte?: Maybe<String>;
  nameSchedule_contains?: Maybe<String>;
  nameSchedule_not_contains?: Maybe<String>;
  nameSchedule_starts_with?: Maybe<String>;
  nameSchedule_not_starts_with?: Maybe<String>;
  nameSchedule_ends_with?: Maybe<String>;
  nameSchedule_not_ends_with?: Maybe<String>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  amountOfWorkingHours?: Maybe<Float>;
  amountOfWorkingHours_not?: Maybe<Float>;
  amountOfWorkingHours_in?: Maybe<Float[] | Float>;
  amountOfWorkingHours_not_in?: Maybe<Float[] | Float>;
  amountOfWorkingHours_lt?: Maybe<Float>;
  amountOfWorkingHours_lte?: Maybe<Float>;
  amountOfWorkingHours_gt?: Maybe<Float>;
  amountOfWorkingHours_gte?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  typeOfWeek_not?: Maybe<Float>;
  typeOfWeek_in?: Maybe<Float[] | Float>;
  typeOfWeek_not_in?: Maybe<Float[] | Float>;
  typeOfWeek_lt?: Maybe<Float>;
  typeOfWeek_lte?: Maybe<Float>;
  typeOfWeek_gt?: Maybe<Float>;
  typeOfWeek_gte?: Maybe<Float>;
  theader?: Maybe<String>;
  theader_not?: Maybe<String>;
  theader_in?: Maybe<String[] | String>;
  theader_not_in?: Maybe<String[] | String>;
  theader_lt?: Maybe<String>;
  theader_lte?: Maybe<String>;
  theader_gt?: Maybe<String>;
  theader_gte?: Maybe<String>;
  theader_contains?: Maybe<String>;
  theader_not_contains?: Maybe<String>;
  theader_starts_with?: Maybe<String>;
  theader_not_starts_with?: Maybe<String>;
  theader_ends_with?: Maybe<String>;
  theader_not_ends_with?: Maybe<String>;
  AND?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  OR?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
  NOT?: Maybe<ScheduleScalarWhereInput[] | ScheduleScalarWhereInput>;
}

export interface ScheduleUpdateManyWithWhereNestedInput {
  where: ScheduleScalarWhereInput;
  data: ScheduleUpdateManyDataInput;
}

export interface ScheduleUpdateManyDataInput {
  nameSchedule?: Maybe<String>;
  year?: Maybe<Int>;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  theader?: Maybe<String>;
}

export interface UserUpdateManyWithoutOwnerInput {
  create?: Maybe<UserCreateWithoutOwnerInput[] | UserCreateWithoutOwnerInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutOwnerInput[]
    | UserUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutOwnerInput[]
    | UserUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutOwnerInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutOwnerDataInput;
}

export interface UserUpdateWithoutOwnerDataInput {
  fullname?: Maybe<String>;
  position?: Maybe<PositionUpdateOneRequiredInput>;
  rateOfWork?: Maybe<Float>;
}

export interface PositionUpdateOneRequiredInput {
  create?: Maybe<PositionCreateInput>;
  update?: Maybe<PositionUpdateDataInput>;
  upsert?: Maybe<PositionUpsertNestedInput>;
}

export interface PositionUpdateDataInput {
  namePosition?: Maybe<String>;
  hoursOfWork?: Maybe<WorkTimeUpdateOneRequiredInput>;
  secondHoursOfWork?: Maybe<SecondWorkTimeUpdateOneInput>;
  lunch?: Maybe<LunchTimeUpdateOneInput>;
  secondLunch?: Maybe<SecondLunchTimeUpdateOneInput>;
  fulltime?: Maybe<Boolean>;
  longOfDay?: Maybe<String>;
  hoursOfMonth?: Maybe<String>;
}

export interface WorkTimeUpdateOneRequiredInput {
  create?: Maybe<WorkTimeCreateInput>;
  update?: Maybe<WorkTimeUpdateDataInput>;
  upsert?: Maybe<WorkTimeUpsertNestedInput>;
}

export interface WorkTimeUpdateDataInput {
  startWork?: Maybe<String>;
  endWork?: Maybe<String>;
}

export interface WorkTimeUpsertNestedInput {
  update: WorkTimeUpdateDataInput;
  create: WorkTimeCreateInput;
}

export interface SecondWorkTimeUpdateOneInput {
  create?: Maybe<SecondWorkTimeCreateInput>;
  update?: Maybe<SecondWorkTimeUpdateDataInput>;
  upsert?: Maybe<SecondWorkTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SecondWorkTimeUpdateDataInput {
  startSecondWork?: Maybe<String>;
  endSecondWork?: Maybe<String>;
}

export interface SecondWorkTimeUpsertNestedInput {
  update: SecondWorkTimeUpdateDataInput;
  create: SecondWorkTimeCreateInput;
}

export interface LunchTimeUpdateOneInput {
  create?: Maybe<LunchTimeCreateInput>;
  update?: Maybe<LunchTimeUpdateDataInput>;
  upsert?: Maybe<LunchTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface LunchTimeUpdateDataInput {
  startLunch?: Maybe<String>;
  endLunch?: Maybe<String>;
}

export interface LunchTimeUpsertNestedInput {
  update: LunchTimeUpdateDataInput;
  create: LunchTimeCreateInput;
}

export interface SecondLunchTimeUpdateOneInput {
  create?: Maybe<SecondLunchTimeCreateInput>;
  update?: Maybe<SecondLunchTimeUpdateDataInput>;
  upsert?: Maybe<SecondLunchTimeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface SecondLunchTimeUpdateDataInput {
  startSecondLunch?: Maybe<String>;
  endSecondLunch?: Maybe<String>;
}

export interface SecondLunchTimeUpsertNestedInput {
  update: SecondLunchTimeUpdateDataInput;
  create: SecondLunchTimeCreateInput;
}

export interface PositionUpsertNestedInput {
  update: PositionUpdateDataInput;
  create: PositionCreateInput;
}

export interface UserUpsertWithWhereUniqueWithoutOwnerInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutOwnerDataInput;
  create: UserCreateWithoutOwnerInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fullname?: Maybe<String>;
  fullname_not?: Maybe<String>;
  fullname_in?: Maybe<String[] | String>;
  fullname_not_in?: Maybe<String[] | String>;
  fullname_lt?: Maybe<String>;
  fullname_lte?: Maybe<String>;
  fullname_gt?: Maybe<String>;
  fullname_gte?: Maybe<String>;
  fullname_contains?: Maybe<String>;
  fullname_not_contains?: Maybe<String>;
  fullname_starts_with?: Maybe<String>;
  fullname_not_starts_with?: Maybe<String>;
  fullname_ends_with?: Maybe<String>;
  fullname_not_ends_with?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
  rateOfWork_not?: Maybe<Float>;
  rateOfWork_in?: Maybe<Float[] | Float>;
  rateOfWork_not_in?: Maybe<Float[] | Float>;
  rateOfWork_lt?: Maybe<Float>;
  rateOfWork_lte?: Maybe<Float>;
  rateOfWork_gt?: Maybe<Float>;
  rateOfWork_gte?: Maybe<Float>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  fullname?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
}

export interface AdminUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  language?: Maybe<String>;
}

export interface ScheduleCreateInput {
  id?: Maybe<ID_Input>;
  nameSchedule: String;
  owner: AdminCreateOneWithoutSchedulesInput;
  year: Int;
  month: MonthCreateOneInput;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek: Float;
  theader?: Maybe<String>;
  employees?: Maybe<EmployeeCreateManyInput>;
}

export interface AdminCreateOneWithoutSchedulesInput {
  create?: Maybe<AdminCreateWithoutSchedulesInput>;
  connect?: Maybe<AdminWhereUniqueInput>;
}

export interface AdminCreateWithoutSchedulesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  language?: Maybe<String>;
  users?: Maybe<UserCreateManyWithoutOwnerInput>;
}

export interface ScheduleUpdateInput {
  nameSchedule?: Maybe<String>;
  owner?: Maybe<AdminUpdateOneRequiredWithoutSchedulesInput>;
  year?: Maybe<Int>;
  month?: Maybe<MonthUpdateOneRequiredInput>;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  theader?: Maybe<String>;
  employees?: Maybe<EmployeeUpdateManyInput>;
}

export interface AdminUpdateOneRequiredWithoutSchedulesInput {
  create?: Maybe<AdminCreateWithoutSchedulesInput>;
  update?: Maybe<AdminUpdateWithoutSchedulesDataInput>;
  upsert?: Maybe<AdminUpsertWithoutSchedulesInput>;
  connect?: Maybe<AdminWhereUniqueInput>;
}

export interface AdminUpdateWithoutSchedulesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  language?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutOwnerInput>;
}

export interface AdminUpsertWithoutSchedulesInput {
  update: AdminUpdateWithoutSchedulesDataInput;
  create: AdminCreateWithoutSchedulesInput;
}

export interface ScheduleUpdateManyMutationInput {
  nameSchedule?: Maybe<String>;
  year?: Maybe<Int>;
  amountOfWorkingHours?: Maybe<Float>;
  typeOfWeek?: Maybe<Float>;
  theader?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  fullname: String;
  owner: AdminCreateOneWithoutUsersInput;
  position: PositionCreateOneInput;
  rateOfWork?: Maybe<Float>;
}

export interface AdminCreateOneWithoutUsersInput {
  create?: Maybe<AdminCreateWithoutUsersInput>;
  connect?: Maybe<AdminWhereUniqueInput>;
}

export interface AdminCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  language?: Maybe<String>;
  schedules?: Maybe<ScheduleCreateManyWithoutOwnerInput>;
}

export interface UserUpdateInput {
  fullname?: Maybe<String>;
  owner?: Maybe<AdminUpdateOneRequiredWithoutUsersInput>;
  position?: Maybe<PositionUpdateOneRequiredInput>;
  rateOfWork?: Maybe<Float>;
}

export interface AdminUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<AdminCreateWithoutUsersInput>;
  update?: Maybe<AdminUpdateWithoutUsersDataInput>;
  upsert?: Maybe<AdminUpsertWithoutUsersInput>;
  connect?: Maybe<AdminWhereUniqueInput>;
}

export interface AdminUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  language?: Maybe<String>;
  schedules?: Maybe<ScheduleUpdateManyWithoutOwnerInput>;
}

export interface AdminUpsertWithoutUsersInput {
  update: AdminUpdateWithoutUsersDataInput;
  create: AdminCreateWithoutUsersInput;
}

export interface UserUpdateManyMutationInput {
  fullname?: Maybe<String>;
  rateOfWork?: Maybe<Float>;
}

export interface AdminSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AdminWhereInput>;
  AND?: Maybe<AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput>;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ScheduleWhereInput>;
  AND?: Maybe<
    ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Admin {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  language?: String;
}

export interface AdminPromise extends Promise<Admin>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  language: () => Promise<String>;
  schedules: <T = FragmentableArray<Schedule>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AdminSubscription
  extends Promise<AsyncIterator<Admin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
  schedules: <T = Promise<AsyncIterator<ScheduleSubscription>>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AdminNullablePromise
  extends Promise<Admin | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  language: () => Promise<String>;
  schedules: <T = FragmentableArray<Schedule>>(args?: {
    where?: ScheduleWhereInput;
    orderBy?: ScheduleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Schedule {
  id: ID_Output;
  nameSchedule: String;
  year: Int;
  month: Month;
  amountOfWorkingHours?: Float;
  typeOfWeek: Float;
  theader?: String;
  employees?: <T = FragmentableArray<Employee>>() => T;
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  id: () => Promise<ID_Output>;
  nameSchedule: () => Promise<String>;
  owner: <T = AdminPromise>() => T;
  year: () => Promise<Int>;
  month: <T = MonthPromise>() => T;
  amountOfWorkingHours: () => Promise<Float>;
  typeOfWeek: () => Promise<Float>;
  theader: () => Promise<String>;
  employees: <T = FragmentableArray<Employee>>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameSchedule: () => Promise<AsyncIterator<String>>;
  owner: <T = AdminSubscription>() => T;
  year: () => Promise<AsyncIterator<Int>>;
  month: <T = MonthSubscription>() => T;
  amountOfWorkingHours: () => Promise<AsyncIterator<Float>>;
  typeOfWeek: () => Promise<AsyncIterator<Float>>;
  theader: () => Promise<AsyncIterator<String>>;
  employees: <T = Promise<AsyncIterator<EmployeeSubscription>>>() => T;
}

export interface ScheduleNullablePromise
  extends Promise<Schedule | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameSchedule: () => Promise<String>;
  owner: <T = AdminPromise>() => T;
  year: () => Promise<Int>;
  month: <T = MonthPromise>() => T;
  amountOfWorkingHours: () => Promise<Float>;
  typeOfWeek: () => Promise<Float>;
  theader: () => Promise<String>;
  employees: <T = FragmentableArray<Employee>>() => T;
}

export interface Month {
  id: ID_Output;
  days?: <T = FragmentableArray<Day>>() => T;
  nameOfMonth: String;
  daysAmount: Int;
  weekdays?: <T = FragmentableArray<Weekday>>() => T;
  weekends?: <T = FragmentableArray<Weekend>>() => T;
  holidays?: <T = FragmentableArray<Holiday>>() => T;
  beforeHolidays?: <T = FragmentableArray<BeforeHoliday>>() => T;
}

export interface MonthPromise extends Promise<Month>, Fragmentable {
  id: () => Promise<ID_Output>;
  days: <T = FragmentableArray<Day>>() => T;
  nameOfMonth: () => Promise<String>;
  daysAmount: () => Promise<Int>;
  weekdays: <T = FragmentableArray<Weekday>>() => T;
  weekends: <T = FragmentableArray<Weekend>>() => T;
  holidays: <T = FragmentableArray<Holiday>>() => T;
  beforeHolidays: <T = FragmentableArray<BeforeHoliday>>() => T;
}

export interface MonthSubscription
  extends Promise<AsyncIterator<Month>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  days: <T = Promise<AsyncIterator<DaySubscription>>>() => T;
  nameOfMonth: () => Promise<AsyncIterator<String>>;
  daysAmount: () => Promise<AsyncIterator<Int>>;
  weekdays: <T = Promise<AsyncIterator<WeekdaySubscription>>>() => T;
  weekends: <T = Promise<AsyncIterator<WeekendSubscription>>>() => T;
  holidays: <T = Promise<AsyncIterator<HolidaySubscription>>>() => T;
  beforeHolidays: <
    T = Promise<AsyncIterator<BeforeHolidaySubscription>>
  >() => T;
}

export interface MonthNullablePromise
  extends Promise<Month | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  days: <T = FragmentableArray<Day>>() => T;
  nameOfMonth: () => Promise<String>;
  daysAmount: () => Promise<Int>;
  weekdays: <T = FragmentableArray<Weekday>>() => T;
  weekends: <T = FragmentableArray<Weekend>>() => T;
  holidays: <T = FragmentableArray<Holiday>>() => T;
  beforeHolidays: <T = FragmentableArray<BeforeHoliday>>() => T;
}

export interface Day {
  id: ID_Output;
  number: Int;
  weekday?: Boolean;
  weekend?: Boolean;
  holiday?: Boolean;
  beforeHoliday?: Boolean;
  kindOfDay?: KindOfDay | null;
}

export interface DayPromise extends Promise<Day>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  weekday: () => Promise<Boolean>;
  weekend: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  beforeHoliday: () => Promise<Boolean>;
  kindOfDay: <T = KindOfDayPromise>() => T;
}

export interface DaySubscription
  extends Promise<AsyncIterator<Day>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  weekday: () => Promise<AsyncIterator<Boolean>>;
  weekend: () => Promise<AsyncIterator<Boolean>>;
  holiday: () => Promise<AsyncIterator<Boolean>>;
  beforeHoliday: () => Promise<AsyncIterator<Boolean>>;
  kindOfDay: <T = KindOfDaySubscription>() => T;
}

export interface DayNullablePromise extends Promise<Day | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  weekday: () => Promise<Boolean>;
  weekend: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  beforeHoliday: () => Promise<Boolean>;
  kindOfDay: <T = KindOfDayPromise>() => T;
}

export interface KindOfDay {
  businessTrip?: Boolean;
  study?: Boolean;
  studyAdd?: Boolean;
  unknown?: Boolean;
  absenteeism?: Boolean;
  goverment?: Boolean;
  holiday?: Boolean;
  disease?: Boolean;
  vacation?: Boolean;
  childCare?: Boolean;
  admVacation?: Boolean;
  overTime?: Boolean;
  nightTime?: Boolean;
  working?: Boolean;
}

export interface KindOfDayPromise extends Promise<KindOfDay>, Fragmentable {
  businessTrip: () => Promise<Boolean>;
  study: () => Promise<Boolean>;
  studyAdd: () => Promise<Boolean>;
  unknown: () => Promise<Boolean>;
  absenteeism: () => Promise<Boolean>;
  goverment: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  disease: () => Promise<Boolean>;
  vacation: () => Promise<Boolean>;
  childCare: () => Promise<Boolean>;
  admVacation: () => Promise<Boolean>;
  overTime: () => Promise<Boolean>;
  nightTime: () => Promise<Boolean>;
  working: () => Promise<Boolean>;
}

export interface KindOfDaySubscription
  extends Promise<AsyncIterator<KindOfDay>>,
    Fragmentable {
  businessTrip: () => Promise<AsyncIterator<Boolean>>;
  study: () => Promise<AsyncIterator<Boolean>>;
  studyAdd: () => Promise<AsyncIterator<Boolean>>;
  unknown: () => Promise<AsyncIterator<Boolean>>;
  absenteeism: () => Promise<AsyncIterator<Boolean>>;
  goverment: () => Promise<AsyncIterator<Boolean>>;
  holiday: () => Promise<AsyncIterator<Boolean>>;
  disease: () => Promise<AsyncIterator<Boolean>>;
  vacation: () => Promise<AsyncIterator<Boolean>>;
  childCare: () => Promise<AsyncIterator<Boolean>>;
  admVacation: () => Promise<AsyncIterator<Boolean>>;
  overTime: () => Promise<AsyncIterator<Boolean>>;
  nightTime: () => Promise<AsyncIterator<Boolean>>;
  working: () => Promise<AsyncIterator<Boolean>>;
}

export interface KindOfDayNullablePromise
  extends Promise<KindOfDay | null>,
    Fragmentable {
  businessTrip: () => Promise<Boolean>;
  study: () => Promise<Boolean>;
  studyAdd: () => Promise<Boolean>;
  unknown: () => Promise<Boolean>;
  absenteeism: () => Promise<Boolean>;
  goverment: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  disease: () => Promise<Boolean>;
  vacation: () => Promise<Boolean>;
  childCare: () => Promise<Boolean>;
  admVacation: () => Promise<Boolean>;
  overTime: () => Promise<Boolean>;
  nightTime: () => Promise<Boolean>;
  working: () => Promise<Boolean>;
}

export interface Weekday {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface WeekdayPromise extends Promise<Weekday>, Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface WeekdaySubscription
  extends Promise<AsyncIterator<Weekday>>,
    Fragmentable {
  num: () => Promise<AsyncIterator<Int>>;
  id: () => Promise<AsyncIterator<String>>;
  isChecked: () => Promise<AsyncIterator<Boolean>>;
}

export interface WeekdayNullablePromise
  extends Promise<Weekday | null>,
    Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface Weekend {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface WeekendPromise extends Promise<Weekend>, Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface WeekendSubscription
  extends Promise<AsyncIterator<Weekend>>,
    Fragmentable {
  num: () => Promise<AsyncIterator<Int>>;
  id: () => Promise<AsyncIterator<String>>;
  isChecked: () => Promise<AsyncIterator<Boolean>>;
}

export interface WeekendNullablePromise
  extends Promise<Weekend | null>,
    Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface Holiday {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface HolidayPromise extends Promise<Holiday>, Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface HolidaySubscription
  extends Promise<AsyncIterator<Holiday>>,
    Fragmentable {
  num: () => Promise<AsyncIterator<Int>>;
  id: () => Promise<AsyncIterator<String>>;
  isChecked: () => Promise<AsyncIterator<Boolean>>;
}

export interface HolidayNullablePromise
  extends Promise<Holiday | null>,
    Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface BeforeHoliday {
  num: Int;
  id: String;
  isChecked: Boolean;
}

export interface BeforeHolidayPromise
  extends Promise<BeforeHoliday>,
    Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface BeforeHolidaySubscription
  extends Promise<AsyncIterator<BeforeHoliday>>,
    Fragmentable {
  num: () => Promise<AsyncIterator<Int>>;
  id: () => Promise<AsyncIterator<String>>;
  isChecked: () => Promise<AsyncIterator<Boolean>>;
}

export interface BeforeHolidayNullablePromise
  extends Promise<BeforeHoliday | null>,
    Fragmentable {
  num: () => Promise<Int>;
  id: () => Promise<String>;
  isChecked: () => Promise<Boolean>;
}

export interface Employee {
  id: ID_Output;
  fullname: String;
  rateOfWork?: Float;
  hoursOfMonth?: String;
  positionOfEmployee: PositionOfEmployee;
  daysOfEmployee?: <T = FragmentableArray<DayOfEmployee>>() => T;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  fullname: () => Promise<String>;
  rateOfWork: () => Promise<Float>;
  hoursOfMonth: () => Promise<String>;
  positionOfEmployee: <T = PositionOfEmployeePromise>() => T;
  daysOfEmployee: <T = FragmentableArray<DayOfEmployee>>() => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullname: () => Promise<AsyncIterator<String>>;
  rateOfWork: () => Promise<AsyncIterator<Float>>;
  hoursOfMonth: () => Promise<AsyncIterator<String>>;
  positionOfEmployee: <T = PositionOfEmployeeSubscription>() => T;
  daysOfEmployee: <
    T = Promise<AsyncIterator<DayOfEmployeeSubscription>>
  >() => T;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fullname: () => Promise<String>;
  rateOfWork: () => Promise<Float>;
  hoursOfMonth: () => Promise<String>;
  positionOfEmployee: <T = PositionOfEmployeePromise>() => T;
  daysOfEmployee: <T = FragmentableArray<DayOfEmployee>>() => T;
}

export interface PositionOfEmployee {
  namePosition: String;
  hoursOfWork: WorkTimeE;
  secondHoursOfWork?: SecondWorkTimeE | null;
  lunch?: LunchTimeE | null;
  secondLunch?: SecondLunchTimeE | null;
  fulltime: Boolean;
  longOfDay: String;
}

export interface PositionOfEmployeePromise
  extends Promise<PositionOfEmployee>,
    Fragmentable {
  namePosition: () => Promise<String>;
  hoursOfWork: <T = WorkTimeEPromise>() => T;
  secondHoursOfWork: <T = SecondWorkTimeEPromise>() => T;
  lunch: <T = LunchTimeEPromise>() => T;
  secondLunch: <T = SecondLunchTimeEPromise>() => T;
  fulltime: () => Promise<Boolean>;
  longOfDay: () => Promise<String>;
}

export interface PositionOfEmployeeSubscription
  extends Promise<AsyncIterator<PositionOfEmployee>>,
    Fragmentable {
  namePosition: () => Promise<AsyncIterator<String>>;
  hoursOfWork: <T = WorkTimeESubscription>() => T;
  secondHoursOfWork: <T = SecondWorkTimeESubscription>() => T;
  lunch: <T = LunchTimeESubscription>() => T;
  secondLunch: <T = SecondLunchTimeESubscription>() => T;
  fulltime: () => Promise<AsyncIterator<Boolean>>;
  longOfDay: () => Promise<AsyncIterator<String>>;
}

export interface PositionOfEmployeeNullablePromise
  extends Promise<PositionOfEmployee | null>,
    Fragmentable {
  namePosition: () => Promise<String>;
  hoursOfWork: <T = WorkTimeEPromise>() => T;
  secondHoursOfWork: <T = SecondWorkTimeEPromise>() => T;
  lunch: <T = LunchTimeEPromise>() => T;
  secondLunch: <T = SecondLunchTimeEPromise>() => T;
  fulltime: () => Promise<Boolean>;
  longOfDay: () => Promise<String>;
}

export interface WorkTimeE {
  startWork: String;
  endWork: String;
}

export interface WorkTimeEPromise extends Promise<WorkTimeE>, Fragmentable {
  startWork: () => Promise<String>;
  endWork: () => Promise<String>;
}

export interface WorkTimeESubscription
  extends Promise<AsyncIterator<WorkTimeE>>,
    Fragmentable {
  startWork: () => Promise<AsyncIterator<String>>;
  endWork: () => Promise<AsyncIterator<String>>;
}

export interface WorkTimeENullablePromise
  extends Promise<WorkTimeE | null>,
    Fragmentable {
  startWork: () => Promise<String>;
  endWork: () => Promise<String>;
}

export interface SecondWorkTimeE {
  startSecondWork: String;
  endSecondWork: String;
}

export interface SecondWorkTimeEPromise
  extends Promise<SecondWorkTimeE>,
    Fragmentable {
  startSecondWork: () => Promise<String>;
  endSecondWork: () => Promise<String>;
}

export interface SecondWorkTimeESubscription
  extends Promise<AsyncIterator<SecondWorkTimeE>>,
    Fragmentable {
  startSecondWork: () => Promise<AsyncIterator<String>>;
  endSecondWork: () => Promise<AsyncIterator<String>>;
}

export interface SecondWorkTimeENullablePromise
  extends Promise<SecondWorkTimeE | null>,
    Fragmentable {
  startSecondWork: () => Promise<String>;
  endSecondWork: () => Promise<String>;
}

export interface LunchTimeE {
  startLunch: String;
  endLunch: String;
}

export interface LunchTimeEPromise extends Promise<LunchTimeE>, Fragmentable {
  startLunch: () => Promise<String>;
  endLunch: () => Promise<String>;
}

export interface LunchTimeESubscription
  extends Promise<AsyncIterator<LunchTimeE>>,
    Fragmentable {
  startLunch: () => Promise<AsyncIterator<String>>;
  endLunch: () => Promise<AsyncIterator<String>>;
}

export interface LunchTimeENullablePromise
  extends Promise<LunchTimeE | null>,
    Fragmentable {
  startLunch: () => Promise<String>;
  endLunch: () => Promise<String>;
}

export interface SecondLunchTimeE {
  startSecondLunch: String;
  endSecondLunch: String;
}

export interface SecondLunchTimeEPromise
  extends Promise<SecondLunchTimeE>,
    Fragmentable {
  startSecondLunch: () => Promise<String>;
  endSecondLunch: () => Promise<String>;
}

export interface SecondLunchTimeESubscription
  extends Promise<AsyncIterator<SecondLunchTimeE>>,
    Fragmentable {
  startSecondLunch: () => Promise<AsyncIterator<String>>;
  endSecondLunch: () => Promise<AsyncIterator<String>>;
}

export interface SecondLunchTimeENullablePromise
  extends Promise<SecondLunchTimeE | null>,
    Fragmentable {
  startSecondLunch: () => Promise<String>;
  endSecondLunch: () => Promise<String>;
}

export interface DayOfEmployee {
  id: ID_Output;
  number: Int;
  weekday?: Boolean;
  weekend?: Boolean;
  holiday?: Boolean;
  beforeHoliday?: Boolean;
  firstStartWork?: String;
  firstStopWork?: String;
  secondStartWork?: String;
  secondStopWork?: String;
  kind: Kind;
}

export interface DayOfEmployeePromise
  extends Promise<DayOfEmployee>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  weekday: () => Promise<Boolean>;
  weekend: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  beforeHoliday: () => Promise<Boolean>;
  firstStartWork: () => Promise<String>;
  firstStopWork: () => Promise<String>;
  secondStartWork: () => Promise<String>;
  secondStopWork: () => Promise<String>;
  kind: <T = KindPromise>() => T;
}

export interface DayOfEmployeeSubscription
  extends Promise<AsyncIterator<DayOfEmployee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  weekday: () => Promise<AsyncIterator<Boolean>>;
  weekend: () => Promise<AsyncIterator<Boolean>>;
  holiday: () => Promise<AsyncIterator<Boolean>>;
  beforeHoliday: () => Promise<AsyncIterator<Boolean>>;
  firstStartWork: () => Promise<AsyncIterator<String>>;
  firstStopWork: () => Promise<AsyncIterator<String>>;
  secondStartWork: () => Promise<AsyncIterator<String>>;
  secondStopWork: () => Promise<AsyncIterator<String>>;
  kind: <T = KindSubscription>() => T;
}

export interface DayOfEmployeeNullablePromise
  extends Promise<DayOfEmployee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  weekday: () => Promise<Boolean>;
  weekend: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  beforeHoliday: () => Promise<Boolean>;
  firstStartWork: () => Promise<String>;
  firstStopWork: () => Promise<String>;
  secondStartWork: () => Promise<String>;
  secondStopWork: () => Promise<String>;
  kind: <T = KindPromise>() => T;
}

export interface Kind {
  businessTrip?: Boolean;
  study?: Boolean;
  studyAdd?: Boolean;
  unknown?: Boolean;
  absenteeism?: Boolean;
  goverment?: Boolean;
  holiday?: Boolean;
  disease?: Boolean;
  vacation?: Boolean;
  childCare?: Boolean;
  admVacation?: Boolean;
  overTime?: Boolean;
  nightTime?: Boolean;
  working?: Boolean;
}

export interface KindPromise extends Promise<Kind>, Fragmentable {
  businessTrip: () => Promise<Boolean>;
  study: () => Promise<Boolean>;
  studyAdd: () => Promise<Boolean>;
  unknown: () => Promise<Boolean>;
  absenteeism: () => Promise<Boolean>;
  goverment: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  disease: () => Promise<Boolean>;
  vacation: () => Promise<Boolean>;
  childCare: () => Promise<Boolean>;
  admVacation: () => Promise<Boolean>;
  overTime: () => Promise<Boolean>;
  nightTime: () => Promise<Boolean>;
  working: () => Promise<Boolean>;
}

export interface KindSubscription
  extends Promise<AsyncIterator<Kind>>,
    Fragmentable {
  businessTrip: () => Promise<AsyncIterator<Boolean>>;
  study: () => Promise<AsyncIterator<Boolean>>;
  studyAdd: () => Promise<AsyncIterator<Boolean>>;
  unknown: () => Promise<AsyncIterator<Boolean>>;
  absenteeism: () => Promise<AsyncIterator<Boolean>>;
  goverment: () => Promise<AsyncIterator<Boolean>>;
  holiday: () => Promise<AsyncIterator<Boolean>>;
  disease: () => Promise<AsyncIterator<Boolean>>;
  vacation: () => Promise<AsyncIterator<Boolean>>;
  childCare: () => Promise<AsyncIterator<Boolean>>;
  admVacation: () => Promise<AsyncIterator<Boolean>>;
  overTime: () => Promise<AsyncIterator<Boolean>>;
  nightTime: () => Promise<AsyncIterator<Boolean>>;
  working: () => Promise<AsyncIterator<Boolean>>;
}

export interface KindNullablePromise
  extends Promise<Kind | null>,
    Fragmentable {
  businessTrip: () => Promise<Boolean>;
  study: () => Promise<Boolean>;
  studyAdd: () => Promise<Boolean>;
  unknown: () => Promise<Boolean>;
  absenteeism: () => Promise<Boolean>;
  goverment: () => Promise<Boolean>;
  holiday: () => Promise<Boolean>;
  disease: () => Promise<Boolean>;
  vacation: () => Promise<Boolean>;
  childCare: () => Promise<Boolean>;
  admVacation: () => Promise<Boolean>;
  overTime: () => Promise<Boolean>;
  nightTime: () => Promise<Boolean>;
  working: () => Promise<Boolean>;
}

export interface User {
  id: ID_Output;
  fullname: String;
  position: Position;
  rateOfWork?: Float;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  fullname: () => Promise<String>;
  owner: <T = AdminPromise>() => T;
  position: <T = PositionPromise>() => T;
  rateOfWork: () => Promise<Float>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullname: () => Promise<AsyncIterator<String>>;
  owner: <T = AdminSubscription>() => T;
  position: <T = PositionSubscription>() => T;
  rateOfWork: () => Promise<AsyncIterator<Float>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fullname: () => Promise<String>;
  owner: <T = AdminPromise>() => T;
  position: <T = PositionPromise>() => T;
  rateOfWork: () => Promise<Float>;
}

export interface Position {
  namePosition: String;
  hoursOfWork: WorkTime;
  secondHoursOfWork?: SecondWorkTime | null;
  lunch?: LunchTime | null;
  secondLunch?: SecondLunchTime | null;
  fulltime: Boolean;
  longOfDay: String;
  hoursOfMonth?: String;
}

export interface PositionPromise extends Promise<Position>, Fragmentable {
  namePosition: () => Promise<String>;
  hoursOfWork: <T = WorkTimePromise>() => T;
  secondHoursOfWork: <T = SecondWorkTimePromise>() => T;
  lunch: <T = LunchTimePromise>() => T;
  secondLunch: <T = SecondLunchTimePromise>() => T;
  fulltime: () => Promise<Boolean>;
  longOfDay: () => Promise<String>;
  hoursOfMonth: () => Promise<String>;
}

export interface PositionSubscription
  extends Promise<AsyncIterator<Position>>,
    Fragmentable {
  namePosition: () => Promise<AsyncIterator<String>>;
  hoursOfWork: <T = WorkTimeSubscription>() => T;
  secondHoursOfWork: <T = SecondWorkTimeSubscription>() => T;
  lunch: <T = LunchTimeSubscription>() => T;
  secondLunch: <T = SecondLunchTimeSubscription>() => T;
  fulltime: () => Promise<AsyncIterator<Boolean>>;
  longOfDay: () => Promise<AsyncIterator<String>>;
  hoursOfMonth: () => Promise<AsyncIterator<String>>;
}

export interface PositionNullablePromise
  extends Promise<Position | null>,
    Fragmentable {
  namePosition: () => Promise<String>;
  hoursOfWork: <T = WorkTimePromise>() => T;
  secondHoursOfWork: <T = SecondWorkTimePromise>() => T;
  lunch: <T = LunchTimePromise>() => T;
  secondLunch: <T = SecondLunchTimePromise>() => T;
  fulltime: () => Promise<Boolean>;
  longOfDay: () => Promise<String>;
  hoursOfMonth: () => Promise<String>;
}

export interface WorkTime {
  startWork: String;
  endWork: String;
}

export interface WorkTimePromise extends Promise<WorkTime>, Fragmentable {
  startWork: () => Promise<String>;
  endWork: () => Promise<String>;
}

export interface WorkTimeSubscription
  extends Promise<AsyncIterator<WorkTime>>,
    Fragmentable {
  startWork: () => Promise<AsyncIterator<String>>;
  endWork: () => Promise<AsyncIterator<String>>;
}

export interface WorkTimeNullablePromise
  extends Promise<WorkTime | null>,
    Fragmentable {
  startWork: () => Promise<String>;
  endWork: () => Promise<String>;
}

export interface SecondWorkTime {
  startSecondWork: String;
  endSecondWork: String;
}

export interface SecondWorkTimePromise
  extends Promise<SecondWorkTime>,
    Fragmentable {
  startSecondWork: () => Promise<String>;
  endSecondWork: () => Promise<String>;
}

export interface SecondWorkTimeSubscription
  extends Promise<AsyncIterator<SecondWorkTime>>,
    Fragmentable {
  startSecondWork: () => Promise<AsyncIterator<String>>;
  endSecondWork: () => Promise<AsyncIterator<String>>;
}

export interface SecondWorkTimeNullablePromise
  extends Promise<SecondWorkTime | null>,
    Fragmentable {
  startSecondWork: () => Promise<String>;
  endSecondWork: () => Promise<String>;
}

export interface LunchTime {
  startLunch: String;
  endLunch: String;
}

export interface LunchTimePromise extends Promise<LunchTime>, Fragmentable {
  startLunch: () => Promise<String>;
  endLunch: () => Promise<String>;
}

export interface LunchTimeSubscription
  extends Promise<AsyncIterator<LunchTime>>,
    Fragmentable {
  startLunch: () => Promise<AsyncIterator<String>>;
  endLunch: () => Promise<AsyncIterator<String>>;
}

export interface LunchTimeNullablePromise
  extends Promise<LunchTime | null>,
    Fragmentable {
  startLunch: () => Promise<String>;
  endLunch: () => Promise<String>;
}

export interface SecondLunchTime {
  startSecondLunch: String;
  endSecondLunch: String;
}

export interface SecondLunchTimePromise
  extends Promise<SecondLunchTime>,
    Fragmentable {
  startSecondLunch: () => Promise<String>;
  endSecondLunch: () => Promise<String>;
}

export interface SecondLunchTimeSubscription
  extends Promise<AsyncIterator<SecondLunchTime>>,
    Fragmentable {
  startSecondLunch: () => Promise<AsyncIterator<String>>;
  endSecondLunch: () => Promise<AsyncIterator<String>>;
}

export interface SecondLunchTimeNullablePromise
  extends Promise<SecondLunchTime | null>,
    Fragmentable {
  startSecondLunch: () => Promise<String>;
  endSecondLunch: () => Promise<String>;
}

export interface AdminConnection {
  pageInfo: PageInfo;
  edges: AdminEdge[];
}

export interface AdminConnectionPromise
  extends Promise<AdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminEdge>>() => T;
  aggregate: <T = AggregateAdminPromise>() => T;
}

export interface AdminConnectionSubscription
  extends Promise<AsyncIterator<AdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdminEdge {
  node: Admin;
  cursor: String;
}

export interface AdminEdgePromise extends Promise<AdminEdge>, Fragmentable {
  node: <T = AdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminEdgeSubscription
  extends Promise<AsyncIterator<AdminEdge>>,
    Fragmentable {
  node: <T = AdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmin {
  count: Int;
}

export interface AggregateAdminPromise
  extends Promise<AggregateAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminSubscription
  extends Promise<AsyncIterator<AggregateAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleConnection {
  pageInfo: PageInfo;
  edges: ScheduleEdge[];
}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedulePromise>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface ScheduleEdge {
  node: Schedule;
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = SchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdminSubscriptionPayload {
  mutation: MutationType;
  node: Admin;
  updatedFields: String[];
  previousValues: AdminPreviousValues;
}

export interface AdminSubscriptionPayloadPromise
  extends Promise<AdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminPreviousValuesPromise>() => T;
}

export interface AdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminPreviousValuesSubscription>() => T;
}

export interface AdminPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  language?: String;
}

export interface AdminPreviousValuesPromise
  extends Promise<AdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  language: () => Promise<String>;
}

export interface AdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  language: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  node: Schedule;
  updatedFields: String[];
  previousValues: SchedulePreviousValues;
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValuesPromise>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface SchedulePreviousValues {
  id: ID_Output;
  nameSchedule: String;
  year: Int;
  amountOfWorkingHours?: Float;
  typeOfWeek: Float;
  theader?: String;
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  nameSchedule: () => Promise<String>;
  year: () => Promise<Int>;
  amountOfWorkingHours: () => Promise<Float>;
  typeOfWeek: () => Promise<Float>;
  theader: () => Promise<String>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nameSchedule: () => Promise<AsyncIterator<String>>;
  year: () => Promise<AsyncIterator<Int>>;
  amountOfWorkingHours: () => Promise<AsyncIterator<Float>>;
  typeOfWeek: () => Promise<AsyncIterator<Float>>;
  theader: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  fullname: String;
  rateOfWork?: Float;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fullname: () => Promise<String>;
  rateOfWork: () => Promise<Float>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fullname: () => Promise<AsyncIterator<String>>;
  rateOfWork: () => Promise<AsyncIterator<Float>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Admin",
    embedded: false
  },
  {
    name: "Schedule",
    embedded: false
  },
  {
    name: "Employee",
    embedded: true
  },
  {
    name: "PositionOfEmployee",
    embedded: true
  },
  {
    name: "WorkTimeE",
    embedded: true
  },
  {
    name: "SecondWorkTimeE",
    embedded: true
  },
  {
    name: "LunchTimeE",
    embedded: true
  },
  {
    name: "SecondLunchTimeE",
    embedded: true
  },
  {
    name: "DayOfEmployee",
    embedded: true
  },
  {
    name: "Kind",
    embedded: true
  },
  {
    name: "Month",
    embedded: true
  },
  {
    name: "Weekday",
    embedded: true
  },
  {
    name: "Weekend",
    embedded: true
  },
  {
    name: "Holiday",
    embedded: true
  },
  {
    name: "BeforeHoliday",
    embedded: true
  },
  {
    name: "Day",
    embedded: true
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Position",
    embedded: true
  },
  {
    name: "WorkTime",
    embedded: true
  },
  {
    name: "SecondWorkTime",
    embedded: true
  },
  {
    name: "LunchTime",
    embedded: true
  },
  {
    name: "SecondLunchTime",
    embedded: true
  },
  {
    name: "KindOfDay",
    embedded: true
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
